Start Contract WhaleGiveaway2
	To analyze：WhaleGiveaway2.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.redeem()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1009.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract BananaGame
	To analyze：BananaGame.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.BananaGame()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.safeSend(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.safeSend(address,uint256)
		contract: BananaGame | function: safeSend(address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'value == 0', 'None', 'this.balance < value', 'None', '! (addr.call.gas(safeGas).value(value)())']
[cfg_Reentrancy in] contract: BananaGame . function: safeSend(address,uint256) | Reentrancy_FP\test1169.sol#1220-1232
	To analyze：BananaGame.setStopped()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.setStarted()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBetNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changePercent(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.watchPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getPlayerBetResult(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: BananaGame | function: divest(address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invest >= investors[currentID].amountInvested)', 'invest -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != investorsNum', 'None', 'investorsNum --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invest >= investors[currentID].amountInvested)', 'invest -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != investorsNum', 'lastInvestor = investors[investorsNum]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[investorsNum]', 'None', 'investorsNum --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: BananaGame . function: divest(address) | Reentrancy_FP\test1169.sol#1364-1389
	To analyze：BananaGame.addInvest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeInvestNum(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeDivestFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getInvestStatus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeORACLIZE_GAS_LIMIT(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getOraFee()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBetKey(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.destroy()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1169.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1204.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: __callback(bytes32,string,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'numberRolled = parseInt(result)', 'bets[myid].numberRolled = numberRolled', 'isWinningBet(bets[myid],numberRolled)', 'isLosingBet(bets[myid],numberRolled)', [['taint', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isWinningBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: __callback(bytes32,string,bytes) | Reentrancy_FP\test1236.sol#730-742
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: isLosingBet(Dice.Bet,uint256) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'LOG_BetLost(thisBet.playerAddress,numberRolled)', 'safeSend(thisBet.playerAddress,1)', '(investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)', 'None', 'totalProfit = investorsProfit + (thisBet.amountBet - 1)', 'investorsProfit += (thisBet.amountBet - 1) * (10000 - houseEdge) / 10000', 'houseProfit = totalProfit - investorsProfit', 'safeSend(houseAddress,houseProfit)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: isLosingBet(Dice.Bet,uint256) | Reentrancy_FP\test1236.sol#761-779
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy_FP\test1236.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1236.sol
Start Contract ERC20
Start Contract OraclesPresale
	To analyze：OraclesPresale.OraclesPresale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.set_saleAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.perform_withdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.refund_me()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.buy_the_tokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.upgrade_cap()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test142.sol
Start Contract DAO
Start Contract WithdrawDAO
	To analyze：WithdrawDAO.withdraw()
		contract: WithdrawDAO | function: withdraw() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'balance = mainDAO.balanceOf(msg.sender)', '! mainDAO.transferFrom(msg.sender,this,balance) || ! msg.sender.send(balance)']
[cfg_Reentrancy in] contract: WithdrawDAO . function: withdraw() | Reentrancy_FP\test1541.sol#15-20
	To analyze：WithdrawDAO.clawback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1541.sol
Start Contract AddressLottery
	To analyze：AddressLottery.AddressLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.participate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.luckyNumberOfAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.reseed(AddressLottery.SeedComponents)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.forceReseed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1559.sol
Start Contract ERC20
Start Contract EnjinBuyer
	To analyze：EnjinBuyer.set_token(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.set_refunded(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.activate_kill_switch(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.personal_withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.withdraw(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.purchase_tokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1698.sol
Start Contract WhaleGiveaway1
	To analyze：WhaleGiveaway1.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.redeem()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1885.sol
Start Contract WhaleGiveaway1
	To analyze：WhaleGiveaway1.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.GetFreebie()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1911.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: __callback(bytes32,string,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'numberRolled = parseInt(result)', 'bets[myid].numberRolled = numberRolled', 'isWinningBet(bets[myid],numberRolled)', 'isLosingBet(bets[myid],numberRolled)', [['taint', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isWinningBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: __callback(bytes32,string,bytes) | Reentrancy_FP\test1948.sol#730-742
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: isLosingBet(Dice.Bet,uint256) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'LOG_BetLost(thisBet.playerAddress,numberRolled)', 'safeSend(thisBet.playerAddress,1)', '(investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)', 'None', 'totalProfit = investorsProfit + (thisBet.amountBet - 1)', 'investorsProfit += (thisBet.amountBet - 1) * (10000 - houseEdge) / 10000', 'houseProfit = totalProfit - investorsProfit', 'safeSend(houseAddress,houseProfit)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: isLosingBet(Dice.Bet,uint256) | Reentrancy_FP\test1948.sol#761-779
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy_FP\test1948.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test1948.sol
Start Contract AmIOnTheFork
Start Contract ReplaySafeSplit
	To analyze：ReplaySafeSplit.split(address,address)
		contract: ReplaySafeSplit | function: split(address,address) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'amIOnTheFork.forked() && targetFork.send(msg.value)']
		contract: ReplaySafeSplit | function: split(address,address) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'amIOnTheFork.forked() && targetFork.send(msg.value)', '! amIOnTheFork.forked() && targetNoFork.send(msg.value)']
[cfg_Reentrancy in] contract: ReplaySafeSplit . function: split(address,address) | Reentrancy_FP\test2014.sol#13-20
	To analyze：ReplaySafeSplit.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2014.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherheroStabilizationFund
	To analyze：EtherheroStabilizationFund.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.ReturnEthToEtherhero()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherhero
	To analyze：Etherhero.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.insertBeneficiaries(address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.getBeneficiaries(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.calculationOfPayment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.receivePercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.makeDeposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2022.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract StandardToken
	To analyze：StandardToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PowerCoin
	To analyze：PowerCoin.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.eT(address,uint256,uint256)
		contract: PowerCoin | function: eT(address,uint256,uint256) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'balances[msg.sender] = safeSub(balances[msg.sender],_tkA)', 'balances[_pd] = safeAdd(balances[_pd],_tkA)', '! _pd.call.value(_etA)()']
[cfg_Reentrancy in] contract: PowerCoin . function: eT(address,uint256,uint256) | Reentrancy_FP\test2092.sol#130-136
	To analyze：PowerCoin.PowerCoin()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferAnyERC20Token(address,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2092.sol
Start Contract ERC20
Start Contract ICOSyndicate
	To analyze：ICOSyndicate.set_addresses(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.activate_kill_switch()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.withdraw(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2153.sol
Start Contract ERC721
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min(int256,int256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bid(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._currentPrice(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCurrentPrice(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsBase
Start Contract EthernautsAccessControl
	To analyze：EthernautsAccessControl.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsStorage
	To analyze：EthernautsStorage.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.EthernautsStorage()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.grantAccess(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.removeAccess(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.createAsset(uint256,address,uint256,uint16,uint8,uint8,uint8,uint8[10],uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.editAsset(uint256,uint256,uint256,uint16,uint8,uint8,uint8,uint8[10],uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.updateStats(uint256,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.updateState(uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setAssetCooldown(uint256,uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.getStats(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.hasAllAttrs(uint256,bytes2)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.hasAnyAttrs(uint256,bytes2)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.isCategory(uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.isState(uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.approvedFor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.getTokenList(address,uint8,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsOwnership
	To analyze：EthernautsOwnership.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.createNewAsset(uint256,address,uint256,uint16,uint8,uint8,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.isExploring(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsLogic
	To analyze：EthernautsLogic.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.createNewAsset(uint256,address,uint256,uint16,uint8,uint8,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.isExploring(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.EthernautsLogic()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setEthernautsStorageContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.withdrawBalances(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.getBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsMarket
	To analyze：EthernautsMarket._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._bid(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._currentPrice(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._computeCurrentPrice(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.createNewAsset(uint256,address,uint256,uint16,uint8,uint8,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.isExploring(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.EthernautsLogic()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setEthernautsStorageContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.withdrawBalances(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.EthernautsMarket(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.bid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.createAuctionWhenPaused(address,address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.createSaleAuction(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setOwnerCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setStepLimits(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setPercentages(uint8,uint8,uint8,uint8,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2333.sol
Start Contract SortitionSumTreeFactory
	To analyze：SortitionSumTreeFactory.createTree(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.set(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.queryLeafs(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.draw(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.stakeOf(SortitionSumTreeFactory.SortitionSumTrees,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.updateParents(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract RNG
	To analyze：RNG.requestRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RNG.getUncorrelatedRN(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Arbitrator
	To analyze：Arbitrator.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IArbitrable
Start Contract Arbitrable
	To analyze：Arbitrable.constructor(Arbitrator,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrable.rule(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract TokenController
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract KlerosLiquid
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.constructor(address,MiniMeToken,RNG,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeGovernorProposal(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeGovernor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changePinakion(MiniMeToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeRNGenerator(RNG)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeMinStakingTime(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeMaxDrawingTime(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createSubcourt(uint96,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtMinStake(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtAlpha(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorFee(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorsForJump(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtTimesPerPeriod(uint96,uint256[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPhase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.setStake(uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeDelayedSetStakes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.drawJurors(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.castCommit(uint256,uint256[],bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.castVote(uint256,uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.computeTokenAndETHRewards(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.execute(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.arbitrationCost(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealCost(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.disputeStatus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.currentRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid._setStake(address,uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.extraDataToSubcourtIDAndMinJurors(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.accountAndSubcourtIDToStakePathID(address,uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakePathIDToAccountAndSubcourtID(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getSubcourt(uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVote(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVoteCounter(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getDispute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getJuror(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakeOf(address,uint96)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2344.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMathLib
	To analyze：SafeMathLib.times(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMathLib.minus(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMathLib.plus(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Haltable
	To analyze：Haltable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Haltable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Haltable.halt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Haltable.unhalt()
		cfg分析安全，所以开始ICFG的分析
Start Contract PricingStrategy
	To analyze：PricingStrategy.isPricingStrategy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PricingStrategy.isSane(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PricingStrategy.isPresalePurchase(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract FinalizeAgent
	To analyze：FinalizeAgent.isFinalizeAgent()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract ERC20
Start Contract FractionalERC20
Start Contract Crowdsale
	To analyze：Crowdsale.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.halt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.unhalt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.Crowdsale(address,PricingStrategy,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.investInternal(address,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.preallocate(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.investWithSignedAddress(address,uint128,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.investWithCustomerId(address,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.invest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buyWithSignedAddress(uint128,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buyWithCustomerId(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setFinalizeAgent(FinalizeAgent)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setRequireCustomerId(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setRequireSignedAddress(bool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setEarlyParicipantWhitelist(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setEndsAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setPricingStrategy(PricingStrategy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setMultisig(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.loadRefund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.refund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isMinimumGoalReached()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isFinalizerSane()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isPricingSane()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.getState()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setOwnerTestValue(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isCrowdsale()
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.isToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PreICOProxyBuyer
	To analyze：PreICOProxyBuyer.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.halt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.unhalt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.PreICOProxyBuyer(address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.invest(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.buyWithCustomerId(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.buyForEverybody()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getClaimAmount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getClaimLeft(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.claimAll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.claim(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.refund()
		contract: PreICOProxyBuyer | function: refund() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'getState() != State.Refunding', 'None', 'investor = msg.sender', 'balances[investor] == 0', 'None', 'amount = balances[investor]', 'delete balances[investor]', '! (investor.call.value(amount)())']
[cfg_Reentrancy in] contract: PreICOProxyBuyer . function: refund() | Reentrancy_FP\test2488.sol#1172-1183
	To analyze：PreICOProxyBuyer.setCrowdsale(Crowdsale)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.forceRefund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.loadRefund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getState()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.isPresale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2488.sol
Start Contract PreSaleFund
	To analyze：PreSaleFund.loggedTransfer(uint256,bytes32,address,address)
		contract: PreSaleFund | function: loggedTransfer(uint256,bytes32,address,address) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'msg.sender != address(this)', 'None', 'target.call.value(amount)()']
[cfg_Reentrancy in] contract: PreSaleFund . function: loggedTransfer(uint256,bytes32,address,address) | Reentrancy_FP\test2502.sol#12-20
	To analyze：PreSaleFund.Invest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.Divest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.GetInvestedAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.withdraw()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2502.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract InvestorsStorage
	To analyze：InvestorsStorage.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.updateInfo(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.updateCheckpoint(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.addReferrer(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.getInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.d(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.c(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.r(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartPyramid
	To analyze：SmartPyramid.bytesToAddress(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.addReferrer(uint256)
		contract: SmartPyramid | function: addReferrer(uint256) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', '_referrer = bytesToAddress(bytes(msg.data))', '_referrer != msg.sender', 'x.addReferrer(msg.sender,_referrer)', 'x.r(msg.sender).transfer(_value / 20)']
[cfg_Reentrancy in] contract: SmartPyramid . function: addReferrer(uint256) | Reentrancy_FP\test2597.sol#190-198
	To analyze：SmartPyramid.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.getInfo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.getTop()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.invest()
		contract: SmartPyramid | function: invest() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'admin.transfer(msg.value * 4 / 25)', 'x.d(msg.sender) > 0', 'None', 'x.updateInfo(msg.sender,msg.value)', 'msg.value > top[3].deposit', 'None', 'x.r(msg.sender) != 0x0', 'x.r(msg.sender).transfer(msg.value / 20)']
			path: ['entryPoint', 'admin.transfer(msg.value * 4 / 25)', 'x.d(msg.sender) > 0', 'None', 'x.updateInfo(msg.sender,msg.value)', 'msg.value > top[3].deposit', 'toTheTop()', 'None', 'x.r(msg.sender) != 0x0', 'x.r(msg.sender).transfer(msg.value / 20)']
			path: ['entryPoint', 'admin.transfer(msg.value * 4 / 25)', 'x.d(msg.sender) > 0', 'withdraw()', 'None', 'x.updateInfo(msg.sender,msg.value)', 'msg.value > top[3].deposit', 'None', 'x.r(msg.sender) != 0x0', 'x.r(msg.sender).transfer(msg.value / 20)']
			path: ['entryPoint', 'admin.transfer(msg.value * 4 / 25)', 'x.d(msg.sender) > 0', 'withdraw()', 'None', 'x.updateInfo(msg.sender,msg.value)', 'msg.value > top[3].deposit', 'toTheTop()', 'None', 'x.r(msg.sender) != 0x0', 'x.r(msg.sender).transfer(msg.value / 20)']
[cfg_Reentrancy in] contract: SmartPyramid . function: invest() | Reentrancy_FP\test2597.sol#226-249
	To analyze：SmartPyramid.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.toTheTop()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.payDay()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.nextWave()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2597.sol
Start Contract ERC20Basic
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BasicToken
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract StandardToken
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecTokenSmartContract
	To analyze：ElecTokenSmartContract.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.ElecTokenSmartContract(uint256,uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.emergencyERC20Drain(ERC20,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecApprover
	To analyze：ElecApprover.ElecApprover(ElecWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.contributedCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.contributedInternalCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.saleStarted()
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecWhitelist
	To analyze：ElecWhitelist.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.ElecWhitelist()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.listAddress(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.listAddresses(address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.setUsersCap(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.getCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.destroy()
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecSaleSmartContract
	To analyze：ElecSaleSmartContract.ElecApprover(ElecWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.contributedCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.contributedInternalCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.saleStarted()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.ElecSaleSmartContract(address,address,ElecWhitelist,uint256,uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.setHaltSale(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.proxyBuy(bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.sendETHToMultiSig(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.finalizeSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.emergencyDrain(ERC20)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test269.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract TokenController
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Contribution
	To analyze：Contribution.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.Contribution(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.initialize(address,address,address,address,address,address,address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.exchangeRate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.tokensToGenerate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.allowTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.doBuy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollectByInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockNumber()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockTimestamp()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.pauseContribution(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Exchanger
	To analyze：Exchanger.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.Exchanger(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.collect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.getBlockNumber()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.getBlockTimestamp()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2696.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test276.sol
Start Contract BTCRelay
Start Contract PoissonData
Start Contract Escrow
Start Contract EthereumLottery
	To analyze：EthereumLottery.EthereumLottery(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.needsInitialization()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.initLottery(uint256,uint256,uint256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.buyTickets(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.needsFinalization()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.finalizeLottery(uint256)
		contract: EthereumLottery | function: finalizeLottery(uint256) | accessPermision: False | 锁/钱提前更新：True
			path: ['entryPoint', 'require(bool)(needsFinalization())', 'lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock', 'winningTicket = lotteries[id].nearestKnownBlockHash % int256(lotteries[id].numTickets)', 'winner = lotteries[id].tickets[uint256(winningTicket)]', 'lotteries[id].winningTicket = winningTicket', 'lotteries[id].winner = winner', 'lotteries[id].finalizationBlock = block.number', 'lotteries[id].finalizer = tx.origin', 'winner != 0', 'None', '_ = admin.call.gas(GAS_LIMIT).value(this.balance)()']
			path: ['entryPoint', 'require(bool)(needsFinalization())', 'lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock', 'winningTicket = lotteries[id].nearestKnownBlockHash % int256(lotteries[id].numTickets)', 'winner = lotteries[id].tickets[uint256(winningTicket)]', 'lotteries[id].winningTicket = winningTicket', 'lotteries[id].winner = winner', 'lotteries[id].finalizationBlock = block.number', 'lotteries[id].finalizer = tx.origin', 'winner != 0', 'value = lotteries[id].jackpot', 'successful = winner.call.gas(GAS_LIMIT).value(value)()', '! successful', 'None', 'None', '_ = admin.call.gas(GAS_LIMIT).value(this.balance)()']
			path: ['entryPoint', 'require(bool)(needsFinalization())', 'lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock', 'winningTicket = lotteries[id].nearestKnownBlockHash % int256(lotteries[id].numTickets)', 'winner = lotteries[id].tickets[uint256(winningTicket)]', 'lotteries[id].winningTicket = winningTicket', 'lotteries[id].winner = winner', 'lotteries[id].finalizationBlock = block.number', 'lotteries[id].finalizer = tx.origin', 'winner != 0', 'value = lotteries[id].jackpot', 'successful = winner.call.gas(GAS_LIMIT).value(value)()', '! successful', 'Escrow(escrow).deposit.value(value)(winner)', 'None', 'None', '_ = admin.call.gas(GAS_LIMIT).value(this.balance)()']
[cfg_Reentrancy in] contract: EthereumLottery . function: finalizeLottery(uint256) | Reentrancy_FP\test2932.sol#158-184
	To analyze：EthereumLottery.walkTowardsBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getMessageLength(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.setMessage(int256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getLotteryDetailsA(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getLotteryDetailsB(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getTicketDetails(int256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getTicketOwner(int256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getRecentActivity()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.setAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.proposeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.destruct()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test2932.sol
Start Contract Pie
	To analyze：Pie.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Get()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3058.sol
Start Contract IStdToken
Start Contract EtheramaCommon
	To analyze：EtheramaCommon.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isManager(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaGasPriceLimit
	To analyze：EtheramaGasPriceLimit.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaCore
	To analyze：EtheramaCore.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.changeControllerContract(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setBigPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setQuickPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setPromoMinPurchaseEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMinRefEthPurchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setTotalIncomeFeePercent(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setRewardPercentages(uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutQuickBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutBigBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBonusPerShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRewardPayouts(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackBuy(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackSell(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackTotalVolume(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBuyCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getSellCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeEth(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeToken(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserEthVolumeSaldo(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserQuickPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserBigPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTokenLocalBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.subUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserReward(address,address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalReward(address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserReward(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserTotalReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserShareBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawUserReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getRewardAndPrepareWithdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawRemainingEthAfterAll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.calcPercent(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convertRealTo256(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convert256ToReal(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaData
	To analyze：EtheramaData.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.init()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isInited()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCoreAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setNewControllerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getAdministratorCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCommonInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.resetTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setTotalSupply(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setRealTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTokenLocalBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getActualUserTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRewardPayouts(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserReward(address,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTotalPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserBigPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserQuickPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherama
	To analyze：Etherama.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.transferOwnershipRequest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.activate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.finish()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.buy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sell(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.withdrawTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.prepareForMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMaxGasPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getExpirationTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTimeTillExpiration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserAdministrator()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDataContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.requestControllerContractMigration(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.approveControllerContractMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateToNewNewControllerContract()
		contract: Etherama | function: migrateToNewNewControllerContract() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'require(bool)(isMigrationApproved && migrationContractAddress != address(0x0) && isActualContractVer)', 'isActive = false', 'newController = Etherama(address(migrationContractAddress))', '_data.setNewControllerAddress(migrationContractAddress)', 'remainingTokenAmount = getRemainingTokenAmount()', 'ethBalance = getTotalEthBalance()', 'remainingTokenAmount > 0', 'None', 'ethBalance > 0', 'newController.migrateFunds.value(ethBalance)()']
			path: ['entryPoint', 'require(bool)(isMigrationApproved && migrationContractAddress != address(0x0) && isActualContractVer)', 'isActive = false', 'newController = Etherama(address(migrationContractAddress))', '_data.setNewControllerAddress(migrationContractAddress)', 'remainingTokenAmount = getRemainingTokenAmount()', 'ethBalance = getTotalEthBalance()', 'remainingTokenAmount > 0', '_token.transfer(migrationContractAddress,remainingTokenAmount)', 'None', 'ethBalance > 0', 'newController.migrateFunds.value(ethBalance)()']
[cfg_Reentrancy in] contract: Etherama . function: migrateToNewNewControllerContract() | Reentrancy_FP\test3136.sol#1009-1024
	To analyze：Etherama.getBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenInitialPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDevRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getShareRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRefBonusPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedTokenBlock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMinRefEthPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentTokenPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalEthBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserLocalTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserLocalTokenBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getEthDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserReward(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenSellPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenBuyPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateBuyOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateSellOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserMaxPurchase(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserMaxPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserTotalPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.purchaseTokens(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
[Icfg_Reentrancy in] contract: Etherama . function: purchaseTokens(uint256,address,uint256) | Reentrancy_FP\test3136.sol#1287-1317
	To analyze：Etherama.setTotalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.checkAndSendPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.distributeFee(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addProfitPerShare(uint256,address)
		cfg分析安全，所以开始ICFG的分析
		contract: Etherama | function: addProfitPerShare(uint256,address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'refBonus = calcRefBonus(totalFeeEth)', 'totalShareReward = calcTotalShareRewardFee(totalFeeEth)', 'refAddress != address(0x0)', '_core.addUserRefBalance.value(refBonus)(refAddress)', 'None', 'getTotalTokenSold() == 0', '_core.addBonusPerShare.value(totalShareReward)()', [['taint', 'addBonusPerShare()']]]
[Icfg_Reentrancy in] contract: Etherama . function: addProfitPerShare(uint256,address) | Reentrancy_FP\test3136.sol#1355-1370
	To analyze：Etherama.addDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.subUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.updateTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.ethToTokens(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.tokensToEth(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalFee(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calc1RealTokenRateFromRealTokens(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRealPriceSpeed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalShareRewardFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcRefBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract RealMath
	To analyze：RealMath.getMinInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.getMaxInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt256ValidIn64(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt256ValidIn64(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt64ValidIn64(uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt128ValidIn64(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.toReal(int64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fromReal(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.abs(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpartSigned(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.mul(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.div(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fraction(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.hibit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.findbit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.rescale(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.lnLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ln(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.exp(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.pow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3136.sol
Start Contract Pie
	To analyze：Pie.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Get()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3206.sol
Start Contract ERC20
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Distribution
	To analyze：Distribution.Distribution(address,ERC20,bytes32[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.handleTokensReceived()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution._numTokensForContributor(uint256,Distribution.State)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.doDistribution(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.doDistributionRange(uint256,address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.numTokensForContributor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.temporaryEscapeHatch(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.temporaryKill(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3235.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test329.sol
Start Contract JIincInterfaceForForwarder
Start Contract JIincForwarder
	To analyze：JIincForwarder.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.fallback()
		contract: JIincForwarder | function: fallback() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'currentCorpBank_.deposit.value(address(this).balance)(address(currentCorpBank_))']
[cfg_Reentrancy in] contract: JIincForwarder . function: fallback() | Reentrancy_FP\test3369.sol#76-83
	To analyze：JIincForwarder.deposit()
		contract: JIincForwarder | function: deposit() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'require(bool,string)(msg.value > 0,Forwarder Deposit failed - zero deposits not allowed)', 'require(bool,string)(needsBank_ == false,Forwarder Deposit failed - no registered bank)', 'currentCorpBank_.deposit.value(msg.value)(msg.sender) == true']
[cfg_Reentrancy in] contract: JIincForwarder . function: deposit() | Reentrancy_FP\test3369.sol#85-96
	To analyze：JIincForwarder.status()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.startMigration(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.cancelMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.finishMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.setup(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3369.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: __callback(bytes32,string,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'numberRolled = parseInt(result)', 'bets[myid].numberRolled = numberRolled', 'isWinningBet(bets[myid],numberRolled)', 'isLosingBet(bets[myid],numberRolled)', [['taint', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isWinningBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: __callback(bytes32,string,bytes) | Reentrancy_FP\test3377.sol#730-742
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: isLosingBet(Dice.Bet,uint256) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'LOG_BetLost(thisBet.playerAddress,numberRolled)', 'safeSend(thisBet.playerAddress,1)', '(investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)', 'None', 'totalProfit = investorsProfit + (thisBet.amountBet - 1)', 'investorsProfit += (thisBet.amountBet - 1) * (10000 - houseEdge) / 10000', 'houseProfit = totalProfit - investorsProfit', 'safeSend(houseAddress,houseProfit)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: isLosingBet(Dice.Bet,uint256) | Reentrancy_FP\test3377.sol#761-779
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy_FP\test3377.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3377.sol
Start Contract Utils
	To analyze：Utils.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IOwned
	To analyze：IOwned.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract Owned
	To analyze：Owned.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
Start Contract Managed
	To analyze：Managed.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenHolder
	To analyze：ITokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenHolder
	To analyze：TokenHolder.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartTokenController
	To analyze：SmartTokenController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC20Token
	To analyze：IERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract IEtherToken
	To analyze：IEtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISmartToken
	To analyze：ISmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorFormula
Start Contract ITokenChanger
Start Contract BancorChanger
	To analyze：BancorChanger.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.BancorChanger(ISmartToken,IBancorFormula,uint32,IERC20Token,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.reserveTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableToken(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setFormula(IBancorFormula)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setQuickBuyPath(IERC20Token[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.clearQuickBuyPath()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyPathLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.hasQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableChanging(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setChangeFee(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getChangeFeeAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.addReserve(IERC20Token,uint32,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.updateReserve(IERC20Token,uint32,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableReservePurchases(IERC20Token,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReserveBalance(IERC20Token)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReturn(IERC20Token,IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getPurchaseReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.change(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.buy(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.sell(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickChange(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickBuy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.ensureAllowance(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.claimTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorLender
	To analyze：BancorLender.isCollateralWithinMargin(uint256,uint256,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.offerPosition(uint256,uint32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.takePosition(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.addCollateral(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.closePosition(uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3492.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: __callback(bytes32,string,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'numberRolled = parseInt(result)', 'bets[myid].numberRolled = numberRolled', 'isWinningBet(bets[myid],numberRolled)', 'isLosingBet(bets[myid],numberRolled)', [['taint', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isWinningBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: __callback(bytes32,string,bytes) | Reentrancy_FP\test3516.sol#730-742
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: isLosingBet(Dice.Bet,uint256) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'LOG_BetLost(thisBet.playerAddress,numberRolled)', 'safeSend(thisBet.playerAddress,1)', '(investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)', 'None', 'totalProfit = investorsProfit + (thisBet.amountBet - 1)', 'investorsProfit += (thisBet.amountBet - 1) * (10000 - houseEdge) / 10000', 'houseProfit = totalProfit - investorsProfit', 'safeSend(houseAddress,houseProfit)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: isLosingBet(Dice.Bet,uint256) | Reentrancy_FP\test3516.sol#761-779
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy_FP\test3516.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3516.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract BettingControllerInterface
Start Contract Betting
	To analyze：Betting.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.Betting()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.changeOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.placeBet(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.setupRace(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.reward()
		contract: Betting | function: reward() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'horses.BTC_delta = int32(coinIndex[horses.BTC].post - coinIndex[horses.BTC].pre) * 100000 / int32(coinIndex[horses.BTC].pre)', 'horses.ETH_delta = int32(coinIndex[horses.ETH].post - coinIndex[horses.ETH].pre) * 100000 / int32(coinIndex[horses.ETH].pre)', 'horses.LTC_delta = int32(coinIndex[horses.LTC].post - coinIndex[horses.LTC].pre) * 100000 / int32(coinIndex[horses.LTC].pre)', 'total_reward = (coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total)', 'total_bettors <= 1', 'house_fee = total_reward.mul(5).div(100)', 'require(bool)(house_fee < address(this).balance)', 'total_reward = total_reward.sub(house_fee)', 'bettingControllerInstance.depositHouseTakeout.value(house_fee)()']
[cfg_Reentrancy in] contract: Betting . function: reward() | Reentrancy_FP\test3532.sol#1263-1324
	To analyze：Betting.calculateReward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.checkReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.claim_reward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.forceVoidRace()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.stringToUintNormalize(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.getCoinIndex(bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.reward_total()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.refund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.recovery()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3532.sol
Start Contract DSSafeAddSub
	To analyze：DSSafeAddSub.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract LuckyDice
	To analyze：LuckyDice.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.LuckyDice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.playerMakeBet(uint256,uint256,bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.getFullProfit(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.getProfit(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.getToJackpot(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.withdraw(bytes32,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.playerWithdrawPendingTransactions()
		contract: LuckyDice | function: playerWithdrawPendingTransactions() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'withdrawAmount = playerPendingWithdrawals[msg.sender]', 'playerPendingWithdrawals[msg.sender] = 0', 'msg.sender.call.value(withdrawAmount)()']
[cfg_Reentrancy in] contract: LuckyDice . function: playerWithdrawPendingTransactions() | Reentrancy_FP\test3610.sol#358-373
	To analyze：LuckyDice.playerGetPendingTxByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerUpdateContractBalance(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetHouseEdge(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetMaxProfit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetJpMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerTransferEther(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerRefundPlayer(bytes32,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerPauseGame(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerPausePayouts(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetCasino(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerChangeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerkill()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3610.sol
Start Contract WinEthFree
	To analyze：WinEthFree.isInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.resetInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.calcInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.withdrawInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doInvest(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.WinnerNotReturn(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doBet(address,uint256,WinEthFree.WagerType)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.drawLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.random(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLuckyTickets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.sort(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.quickSort(uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.payTicketsPrize(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextWave()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextBet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeCommission(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doLeverageBet(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLeverageAddress()
		cfg分析安全，所以开始ICFG的分析
Start Contract Leverage
	To analyze：Leverage.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Leverage.fallback()
		contract: Leverage | function: fallback() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'value = msg.value', 'value > 0', 'address(mainContract).transfer(value)', 'None', 'value = uint256(value / minInvestment) * minInvestment', 'mainContract.doLeverageBet(msg.sender,value)']
[cfg_Reentrancy in] contract: Leverage . function: fallback() | Reentrancy_FP\test3654.sol#457-468
./Reentrancy_FP\test3654.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: __callback(bytes32,string,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'numberRolled = parseInt(result)', 'bets[myid].numberRolled = numberRolled', 'isWinningBet(bets[myid],numberRolled)', 'isLosingBet(bets[myid],numberRolled)', [['taint', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isWinningBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: __callback(bytes32,string,bytes) | Reentrancy_FP\test3714.sol#730-742
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: isLosingBet(Dice.Bet,uint256) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'LOG_BetLost(thisBet.playerAddress,numberRolled)', 'safeSend(thisBet.playerAddress,1)', '(investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)', 'None', 'totalProfit = investorsProfit + (thisBet.amountBet - 1)', 'investorsProfit += (thisBet.amountBet - 1) * (10000 - houseEdge) / 10000', 'houseProfit = totalProfit - investorsProfit', 'safeSend(houseAddress,houseProfit)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: isLosingBet(Dice.Bet,uint256) | Reentrancy_FP\test3714.sol#761-779
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy_FP\test3714.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3714.sol
Start Contract IStdToken
Start Contract EtheramaCommon
	To analyze：EtheramaCommon.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isManager(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaGasPriceLimit
	To analyze：EtheramaGasPriceLimit.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaCore
	To analyze：EtheramaCore.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.changeControllerContract(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setBigPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setQuickPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setPromoMinPurchaseEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMinRefEthPurchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setTotalIncomeFeePercent(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setRewardPercentages(uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutQuickBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutBigBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBonusPerShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRewardPayouts(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackBuy(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackSell(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackTotalVolume(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBuyCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getSellCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeEth(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeToken(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserEthVolumeSaldo(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserQuickPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserBigPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTokenLocalBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.subUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserReward(address,address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalReward(address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserReward(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserTotalReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserShareBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawUserReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getRewardAndPrepareWithdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawRemainingEthAfterAll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.calcPercent(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convertRealTo256(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convert256ToReal(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaData
	To analyze：EtheramaData.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.init()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isInited()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCoreAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setNewControllerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getAdministratorCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCommonInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.resetTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setTotalSupply(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setRealTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTokenLocalBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getActualUserTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRewardPayouts(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserReward(address,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTotalPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserBigPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserQuickPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherama
	To analyze：Etherama.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.transferOwnershipRequest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.activate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.finish()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.buy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sell(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.transferTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.withdrawTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.prepareForMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMaxGasPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getExpirationTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTimeTillExpiration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserAdministrator()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDataContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.requestControllerContractMigration(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.approveControllerContractMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateToNewNewControllerContract()
		contract: Etherama | function: migrateToNewNewControllerContract() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'require(bool)(isMigrationApproved && migrationContractAddress != address(0x0) && isActualContractVer)', 'isActive = false', 'newController = Etherama(address(migrationContractAddress))', '_data.setNewControllerAddress(migrationContractAddress)', 'remainingTokenAmount = getRemainingTokenAmount()', 'ethBalance = getTotalEthBalance()', 'remainingTokenAmount > 0', 'None', 'ethBalance > 0', 'newController.migrateFunds.value(ethBalance)()']
			path: ['entryPoint', 'require(bool)(isMigrationApproved && migrationContractAddress != address(0x0) && isActualContractVer)', 'isActive = false', 'newController = Etherama(address(migrationContractAddress))', '_data.setNewControllerAddress(migrationContractAddress)', 'remainingTokenAmount = getRemainingTokenAmount()', 'ethBalance = getTotalEthBalance()', 'remainingTokenAmount > 0', '_token.transfer(migrationContractAddress,remainingTokenAmount)', 'None', 'ethBalance > 0', 'newController.migrateFunds.value(ethBalance)()']
[cfg_Reentrancy in] contract: Etherama . function: migrateToNewNewControllerContract() | Reentrancy_FP\test3730.sol#1016-1031
	To analyze：Etherama.getBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenInitialPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDevRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getShareRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRefBonusPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedTokenBlock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMinRefEthPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentTokenPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalEthBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserLocalTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserLocalTokenBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getEthDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserReward(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenSellPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenBuyPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateBuyOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateSellOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserMaxPurchase(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserMaxPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserTotalPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.purchaseTokens(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', 'updateTokenPrice(_core.convert256ToReal(tokenAmount))', '_core.trackBuy(msg.sender,ethAmount,tokenAmount)', [['taint', 'trackBuy(address,uint256,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', [['taint', 'addUserTokens(address,uint256)', 'addUserTokenLocalBalance(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', [['taint', 'addUserRewardPayouts(address,uint256)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
		contract: Etherama | function: purchaseTokens(uint256,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'refAddress = address(0x0)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
			path：['None', 'tokenAmount = 0', 'totalFeeEth = 0', 'tokenPrice = 0', '(tokenAmount,totalFeeEth,tokenPrice) = estimateBuyOrder(ethAmount,true)', 'require(bool)(tokenAmount >= minReturn)', '_data._hasMaxPurchaseLimit()', 'require(bool)(getCurrentUserMaxPurchase() >= tokenAmount)', 'None', 'require(bool)(tokenAmount > 0 && (SafeMath.add(tokenAmount,getTotalTokenSold()) > getTotalTokenSold()))', 'refAddress == msg.sender || ! _core.isRefAvailable(refAddress)', 'None', 'distributeFee(totalFeeEth,refAddress)', 'addUserTokens(msg.sender,tokenAmount)', '_core.addUserRewardPayouts(msg.sender,_data.getBonusPerShare() * tokenAmount)', 'checkAndSendPromoBonus(ethAmount)', [['taint', 'checkAndSendPromoBonus(uint256)', 'sendQuickPromoBonus()', 'payoutQuickBonus(address)'], ['taint', 'checkAndSendPromoBonus(uint256)', 'sendBigPromoBonus()', 'payoutBigBonus(address)'], ['eth', 'distributeFee(uint256,address)', 'addProfitPerShare(uint256,address)'], ['eth', 'distributeFee(uint256,address)', 'addDevReward(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addBigPromoBonus(uint256)'], ['eth', 'distributeFee(uint256,address)', 'addQuickPromoBonus(uint256)']]]
[Icfg_Reentrancy in] contract: Etherama . function: purchaseTokens(uint256,address,uint256) | Reentrancy_FP\test3730.sol#1294-1324
	To analyze：Etherama.setTotalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.checkAndSendPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.distributeFee(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addProfitPerShare(uint256,address)
		cfg分析安全，所以开始ICFG的分析
		contract: Etherama | function: addProfitPerShare(uint256,address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'refBonus = calcRefBonus(totalFeeEth)', 'totalShareReward = calcTotalShareRewardFee(totalFeeEth)', 'refAddress != address(0x0)', '_core.addUserRefBalance.value(refBonus)(refAddress)', 'None', 'getTotalTokenSold() == 0', '_core.addBonusPerShare.value(totalShareReward)()', [['taint', 'addBonusPerShare()']]]
[Icfg_Reentrancy in] contract: Etherama . function: addProfitPerShare(uint256,address) | Reentrancy_FP\test3730.sol#1362-1377
	To analyze：Etherama.addDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.subUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.updateTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.ethToTokens(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.tokensToEth(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalFee(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calc1RealTokenRateFromRealTokens(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRealPriceSpeed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalShareRewardFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcRefBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract RealMath
	To analyze：RealMath.getMinInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.getMaxInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt256ValidIn64(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt256ValidIn64(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt64ValidIn64(uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt128ValidIn64(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.toReal(int64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fromReal(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.abs(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpartSigned(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.mul(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.div(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fraction(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.hibit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.findbit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.rescale(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.lnLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ln(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.exp(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.pow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3730.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract TokenController
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Contribution
	To analyze：Contribution.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.Contribution(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.initialize(address,address,address,address,address,address,address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.exchangeRate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.tokensToGenerate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.allowTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.doBuy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollectByInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockNumber()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockTimestamp()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.pauseContribution(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract DevTokensHolder
	To analyze：DevTokensHolder.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.DevTokensHolder(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.collectTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.extractablePercentage()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.months(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.getTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3755.sol
Start Contract WhaleGiveaway2
	To analyze：WhaleGiveaway2.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.GetFreebie()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3763.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.assert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Token
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ReserveToken
	To analyze：ReserveToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.ReserveToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.create(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.destroy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevels
	To analyze：AccountLevels.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevelsTest
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.setAccountLevel(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherDelta
	To analyze：EtherDelta.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.EtherDelta(address,address,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeAccountLevelsAddr(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeAccount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeMake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeTake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeRebate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.withdraw(uint256)
		contract: EtherDelta | function: withdraw(uint256) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'tokens[0][msg.sender] < amount', 'None', 'tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)', '! msg.sender.call.value(amount)()']
[cfg_Reentrancy in] contract: EtherDelta . function: withdraw(uint256) | Reentrancy_FP\test3766.sol#219-224
	To analyze：EtherDelta.depositToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.balanceOf(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.order(address,uint256,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.tradeBalances(address,uint256,address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test3766.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: __callback(bytes32,string,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'numberRolled = parseInt(result)', 'bets[myid].numberRolled = numberRolled', 'isWinningBet(bets[myid],numberRolled)', 'isLosingBet(bets[myid],numberRolled)', [['taint', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isWinningBet(Dice.Bet,uint256)', 'safeSend(address,uint256)'], ['eth', 'isLosingBet(Dice.Bet,uint256)', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: __callback(bytes32,string,bytes) | Reentrancy_FP\test470.sol#730-742
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: isLosingBet(Dice.Bet,uint256) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'LOG_BetLost(thisBet.playerAddress,numberRolled)', 'safeSend(thisBet.playerAddress,1)', '(investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)', 'None', 'totalProfit = investorsProfit + (thisBet.amountBet - 1)', 'investorsProfit += (thisBet.amountBet - 1) * (10000 - houseEdge) / 10000', 'houseProfit = totalProfit - investorsProfit', 'safeSend(houseAddress,houseProfit)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: isLosingBet(Dice.Bet,uint256) | Reentrancy_FP\test470.sol#761-779
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy_FP\test470.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test470.sol
Start Contract MarketPrice
	To analyze：MarketPrice.MarketPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.getToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.ETH(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.USD(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.EUR(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.GBP(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.updatedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.update(uint256,string,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.deleteToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.changeCreator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.changeSender(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.execute(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.requestUpdate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.donate()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test509.sol
Start Contract ERC20
Start Contract EnjinBuyer
	To analyze：EnjinBuyer.set_sale_address(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.activate_kill_switch(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.withdraw(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.add_to_buy_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.add_to_withdraw_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.claim_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test524.sol
Start Contract SafeMath
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract ERC20Interface
Start Contract Owned
	To analyze：Owned.owned()
		cfg分析安全，所以开始ICFG的分析
Start Contract METADOLLAR
	To analyze：METADOLLAR.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.STARTMETADOLLAR()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.calculateTheEndPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkFrozenAccounts(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.sell2(address)
		contract: METADOLLAR | function: sell2(address) | accessPermision: False | 锁/钱提前更新：True
			path: ['entryPoint', 'token = METADOLLAR(_tokenAddress)', 'tokens = msg.value * sellPrice', 'require(bool)(token.balanceOf(this) >= tokens)', 'commission = msg.value / commissionRate', 'require(bool)(address(this).send(commission))', 'token.transfer(msg.sender,tokens)']
[cfg_Reentrancy in] contract: METADOLLAR . function: sell2(address) | Reentrancy_FP\test568.sol#219-226
	To analyze：METADOLLAR.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkMinimalGoal()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkIcoStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.buyToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.updatePrices()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setICOPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setSellRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setCommissionRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setDolRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setEthRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.mintToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.destroyToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.collect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.stopThisIco(bool)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test568.sol
Start Contract Utils
	To analyze：Utils.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IOwned
	To analyze：IOwned.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract Owned
	To analyze：Owned.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
Start Contract Managed
	To analyze：Managed.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenHolder
	To analyze：ITokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenHolder
	To analyze：TokenHolder.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartTokenController
	To analyze：SmartTokenController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC20Token
	To analyze：IERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract IEtherToken
	To analyze：IEtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISmartToken
	To analyze：ISmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorFormula
Start Contract ITokenChanger
Start Contract BancorChanger
	To analyze：BancorChanger.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.BancorChanger(ISmartToken,IBancorFormula,uint32,IERC20Token,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.reserveTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableToken(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setFormula(IBancorFormula)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setQuickBuyPath(IERC20Token[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.clearQuickBuyPath()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyPathLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.hasQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableChanging(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setChangeFee(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getChangeFeeAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.addReserve(IERC20Token,uint32,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.updateReserve(IERC20Token,uint32,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableReservePurchases(IERC20Token,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReserveBalance(IERC20Token)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReturn(IERC20Token,IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getPurchaseReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.change(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.buy(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.sell(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickChange(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickBuy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.ensureAllowance(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.claimTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test587.sol
Start Contract WinEthFree
	To analyze：WinEthFree.isInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.resetInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.calcInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.withdrawInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doInvest(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.WinnerNotReturn(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doBet(address,uint256,WinEthFree.WagerType)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.drawLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.random(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLuckyTickets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.sort(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.quickSort(uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.payTicketsPrize(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextWave()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextBet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeCommission(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doLeverageBet(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLeverageAddress()
		cfg分析安全，所以开始ICFG的分析
Start Contract Leverage
	To analyze：Leverage.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Leverage.fallback()
		contract: Leverage | function: fallback() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'value = msg.value', 'value > 0', 'address(mainContract).transfer(value)', 'None', 'value = uint256(value / minInvestment) * minInvestment', 'mainContract.doLeverageBet(msg.sender,value)']
[cfg_Reentrancy in] contract: Leverage . function: fallback() | Reentrancy_FP\test672.sol#457-468
./Reentrancy_FP\test672.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ContributorApprover
	To analyze：ContributorApprover.ContributorApprover(KyberContributorWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.saleStarted()
		cfg分析安全，所以开始ICFG的分析
Start Contract KyberNetworkTokenSale
	To analyze：KyberNetworkTokenSale.ContributorApprover(KyberContributorWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.saleStarted()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.KyberNetworkTokenSale(address,address,KyberContributorWhitelist,uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.setHaltSale(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.proxyBuy(bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.sendETHToMultiSig(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.finalizeSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.emergencyDrain(ERC20)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.debugBuy()
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract KyberContributorWhitelist
	To analyze：KyberContributorWhitelist.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.KyberContributorWhitelist()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.listAddress(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.listAddresses(address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.setSlackUsersCap(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.getCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.destroy()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract BasicToken
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract StandardToken
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract KyberNetworkCrystal
	To analyze：KyberNetworkCrystal.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.KyberNetworkCrystal(uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.emergencyERC20Drain(ERC20,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test719.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test784.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
Start Contract AddressLottery
	To analyze：AddressLottery.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.AddressLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.participate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.luckyNumberOfAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.reseed(AddressLottery.SeedComponents)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.forceReseed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test793.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract tokenRecipient
Start Contract NamiCrowdSale
	To analyze：NamiCrowdSale.NamiCrowdSale(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferForTeam(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeTransferable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinary(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinaryAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.getPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.burnTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setPresalePhase(NamiCrowdSale.Phase)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setCrowdsaleManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateForInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToBuyer(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BinaryOption
	To analyze：BinaryOption.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.BinaryOption(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeOneSession(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getChooses()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.resetSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.openSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.invest(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getEtherToBuy(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeSession(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PresaleToken
Start Contract ERC223ReceivingContract
Start Contract NamiExchange
	To analyze：NamiExchange.NamiExchange(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallback(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.placeBuyOrder(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallbackBuyer(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeBidOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallbackExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeAskOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.buyNac(address)
		contract: NamiExchange | function: buyNac(address) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)', 'asset = ERC23(NamiAddr)', 'maxEth = (ask[_seller].volume).div(ask[_seller].price)', 'msg.value > maxEth', '_seller.send(maxEth) && msg.sender.send(msg.value.sub(maxEth)) && asset.transfer(msg.sender,ask[_seller].volume)']
		contract: NamiExchange | function: buyNac(address) | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)', 'asset = ERC23(NamiAddr)', 'maxEth = (ask[_seller].volume).div(ask[_seller].price)', 'msg.value > maxEth', '_seller.send(msg.value) && asset.transfer(msg.sender,(msg.value).mul(ask[_seller].price))']
[cfg_Reentrancy in] contract: NamiExchange . function: buyNac(address) | Reentrancy_FP\test799.sol#1007-1033
Start Contract ERC23
Start Contract NamiMultiSigWallet
	To analyze：NamiMultiSigWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.NamiMultiSigWallet(address[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.replaceOwner(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.changeRequirement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.submitTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.confirmTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.revokeConfirmation(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.executeTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.isConfirmed(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmationCount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionCount(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getOwners()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmations(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionIds(uint256,uint256,bool,bool)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test799.sol
Start Contract ArrayLib
	To analyze：ArrayLib.insertInPlace(uint8[],uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract DeckLib
	To analyze：DeckLib.init(DeckLib.Deck,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.getCard(DeckLib.Deck,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.cardDescription(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.cardEmojified(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.cardFacevalue(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.blackjackValue(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.getRandomNumber(uint256,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AbstractBlockjackLogs
Start Contract GameLib
	To analyze：GameLib.init(GameLib.Game,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.tick(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.needsTick(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.checkGameResult(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.checkGameContinues(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.forceStand(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.canDoubleDown(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.playerDecision(GameLib.Game,GameLib.GameState)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.dealInitialCards(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.dealHitCard(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.dealHouseCards(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.endGame(GameLib.Game,GameLib.GameResult)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.closeGame(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.payoutForResult(GameLib.GameResult,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.countHand(uint8[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.bestSum(uint8[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.appendArray(uint8[],uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.compareHands(uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract Blockjack
	To analyze：Blockjack.Blockjack(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.startGame()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.hit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.doubleDown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.stand(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.gameTick(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.recordEndedGame(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.tickRequiredLog(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.gameState(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.setupTrustedAccounts()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.changeDev(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.changeDX(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.changeAdminContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.setSettings(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.registerOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.stopBlockjack()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.startBlockjack()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.addBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.remainingBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.removeBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.migrateBlockjack()
		contract: Blockjack | function: migrateBlockjack() | accessPermision: False | 锁/钱提前更新：False
			path: ['entryPoint', 'stopBlockjack()', 'currentBankroll > initialBankroll', '! ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()']
[cfg_Reentrancy in] contract: Blockjack . function: migrateBlockjack() | Reentrancy_FP\test853.sol#558-566
	To analyze：Blockjack.shareProfits()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test853.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.constructor()
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherheroStabilizationFund
	To analyze：EtherheroStabilizationFund.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.ReturnEthToEtherhero()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherhero
	To analyze：Etherhero.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.insertBeneficiaries(address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.getBeneficiaries(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.calculationOfPayment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.receivePercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.makeDeposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test86.sol
Start Contract RNG
	To analyze：RNG.requestRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RNG.getUncorrelatedRN(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Arbitrator
	To analyze：Arbitrator.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IArbitrable
Start Contract Arbitrable
	To analyze：Arbitrable.constructor(Arbitrator,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrable.rule(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pinakion
	To analyze：Pinakion.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.constructor(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenController
Start Contract SortitionSumTreeFactory
	To analyze：SortitionSumTreeFactory.createTree(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.set(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.queryLeafs(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.draw(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.stakeOf(SortitionSumTreeFactory.SortitionSumTrees,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.updateParents(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BlockHashRNG
	To analyze：BlockHashRNG.requestRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.getUncorrelatedRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.contribute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.getRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.saveRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.getFallbackRN(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract KlerosLiquid
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.constructor(address,Pinakion,RNG,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeGovernorProposal(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeRNGenerator(RNG)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createSubcourt(uint96,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtMinStake(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtAlpha(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorFee(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorsForJump(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtTimesPerPeriod(uint96,uint256[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPhase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.setStake(uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeDelayedSetStakes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.drawJurors(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.commit(uint256,uint256[],bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.vote(uint256,uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.computeTokenAndETHRewards(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.execute(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.arbitrationCost(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealCost(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.disputeStatus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.currentRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid._setStake(address,uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.extraDataToSubcourtIDAndMinJurors(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.accountAndSubcourtIDToStakePathID(address,uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakePathIDToAccountAndSubcourtID(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getSubcourt(uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVote(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVoteCounter(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getDispute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getJuror(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakeOf(address,uint96)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test901.sol
Start Contract Ownable
	To analyze：Ownable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TVCrowdsale
Start Contract TVToken
Start Contract MTVote
	To analyze：MTVote.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.constructor(address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.changeAndVote(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.onTokenReceived(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.setPause(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.clear()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.changeTVTokenAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.changeTVCrowdsaleAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.convertBytesToBytes32(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.bytesToUint(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.toBytes(uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test911.sol
Start Contract ERC721
Start Contract PornstarsInterface
Start Contract PornSceneToken
	To analyze：PornSceneToken.PornSceneToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setPornstarsContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.createPromoScene(address,string,uint256[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.createContractScene(string,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.getScene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._paySceneStarOwners(PornSceneToken.Scene,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._payAwardOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._isGoodAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.starsOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._createScene(string,uint256[],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CryptoPornstarAward
	To analyze：CryptoPornstarAward.PornSceneToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setPornstarsContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.createPromoScene(address,string,uint256[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.createContractScene(string,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getScene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._paySceneStarOwners(PornSceneToken.Scene,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._payAwardOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._isGoodAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.starsOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._createScene(string,uint256[],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._triggerCooldown()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._isTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.rand(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCooldown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getAwardTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getCooldown()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.newAward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getCurrentAward()
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test915.sol
Start Contract MultiplicatorX4
	To analyze：MultiplicatorX4.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MultiplicatorX4.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MultiplicatorX4.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MultiplicatorX4.multiplicate(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy_FP\test989.sol
