Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract ERC20
Start Contract SafeERC20
	To analyze：SafeERC20.safeTransfer(ERC20Basic,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeERC20.safeTransferFrom(ERC20,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeERC20.safeApprove(ERC20,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CanReclaimToken
	To analyze：CanReclaimToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CanReclaimToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CanReclaimToken.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract KYCBase
	To analyze：KYCBase.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract ICOEngineInterface
Start Contract CrowdsaleBase
	To analyze：CrowdsaleBase.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.CrowdsaleBase(uint256,uint256,uint256,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.started()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.ended()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.startTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.endTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.totalTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.releaseTokensTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.forwardFunds(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.validPurchase()
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenVesting
	To analyze：TokenVesting.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.TokenVesting(address,uint256,uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.release(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.revoke(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.releasableAmount(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.vestedAmount(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
Start Contract BasicToken
	To analyze：BasicToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MintableToken
	To analyze：MintableToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.mint(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.finishMinting()
		cfg分析安全，所以开始ICFG的分析
Start Contract PausableToken
	To analyze：PausableToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract UacToken
	To analyze：UacToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.mint(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.finishMinting()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.UacToken()
		cfg分析安全，所以开始ICFG的分析
Start Contract UbiatarPlayVault
	To analyze：UbiatarPlayVault.UbiatarPlayVault(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UbiatarPlayVault.release()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UbiatarPlayVault.releasableAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UbiatarPlayVault.vestedAmount()
		cfg分析安全，所以开始ICFG的分析
Start Contract PresaleTokenVault
	To analyze：PresaleTokenVault.init(address[],uint256[],uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.release(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.release()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.releasableAmount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.vestedAmount(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract UacCrowdsale
	To analyze：UacCrowdsale.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.CrowdsaleBase(uint256,uint256,uint256,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.started()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.ended()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.startTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.endTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.totalTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.releaseTokensTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.forwardFunds(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.UacCrowdsale(address,address,address,address,address,address,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.mintPreAllocatedTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.initPresaleTokenVault(address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.price()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.mintReservationTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.mintTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.closeCrowdsale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.finalise()
		cfg分析安全，所以开始ICFG的分析
Start Contract Reservation
	To analyze：Reservation.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.CrowdsaleBase(uint256,uint256,uint256,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.started()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.ended()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.startTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.endTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.totalTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.releaseTokensTo(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Reservation | function: releaseTokensTo(address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'require(bool)(validPurchase())', 'None', 'None', 'weiAmount = msg.value', 'tokenAmount = weiAmount.mul(price())', 'tokenAmount >= availableTokens', 'capReached = true', 'overflowTokens = tokenAmount.sub(availableTokens)', 'tokenAmount = tokenAmount.sub(overflowTokens)', 'refundWeiAmount = overflowTokens.div(price())', 'weiAmount = weiAmount.sub(refundWeiAmount)', 'buyer.transfer(refundWeiAmount)', 'None', 'weiRaised = weiRaised.add(weiAmount)', 'tokensSold = tokensSold.add(tokenAmount)', 'availableTokens = availableTokens.sub(tokenAmount)', 'mintTokens(buyer,tokenAmount)', [['taint', 'mintTokens(address,uint256)']]]
[Icfg_Reentrancy in] contract: Reservation . function: releaseTokensTo(address) | Reentrancy\test1.sol#472-497
	To analyze：Reservation.forwardFunds(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.Reservation(address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.setCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.price()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.mintTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1.sol
Start Contract WhaleGiveaway2
	To analyze：WhaleGiveaway2.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.redeem()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1009.sol
Start Contract Owned
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenRecipient
Start Contract TokenERC20
	To analyze：TokenERC20.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinToken
	To analyze：MifflinToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: MifflinToken . function: contribution(uint256) | Reentrancy\test1095.sol#216-233
	To analyze：MifflinToken.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BeetBuck
	To analyze：BeetBuck.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: BeetBuck . function: contribution(uint256) | Reentrancy\test1095.sol#216-233
	To analyze：BeetBuck.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.BeetBuck(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NapNickel
	To analyze：NapNickel.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NapNickel . function: contribution(uint256) | Reentrancy\test1095.sol#216-233
	To analyze：NapNickel.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.NapNickel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isLeapYear(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.leapYearsBefore(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDaysInMonth(uint8,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestampParts(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestamp(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getYear(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMonth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDay(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getHour(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMinute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getSecond(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getWeekday(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract QuabityQuarter
	To analyze：QuabityQuarter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: QuabityQuarter . function: contribution(uint256) | Reentrancy\test1095.sol#216-233
	To analyze：QuabityQuarter.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.QuabityQuarter(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract KelevinKoin
	To analyze：KelevinKoin.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: KelevinKoin . function: contribution(uint256) | Reentrancy\test1095.sol#216-233
	To analyze：KelevinKoin.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.KelevinKoin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NnexNote
	To analyze：NnexNote.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NnexNote . function: contribution(uint256) | Reentrancy\test1095.sol#216-233
	To analyze：NnexNote.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.NnexNote(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract DundieDollar
	To analyze：DundieDollar.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: DundieDollar . function: contribution(uint256) | Reentrancy\test1095.sol#216-233
	To analyze：DundieDollar.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.DundieDollar(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addAward(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardBalanceOf(address,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardName(uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinMarket
	To analyze：MifflinMarket.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.MifflinMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setToken(uint8,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeToken(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setActive(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getRewardToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenById(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensByAddress(uint256,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensById(uint256,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.highContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.lowContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1095.sol
Start Contract StringLib
	To analyze：StringLib.uintToBytes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StringLib.bytesToUInt(bytes32)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountingLib
	To analyze：AccountingLib.addFunds(AccountingLib.Bank,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountingLib.Deposit(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountingLib.deposit(AccountingLib.Bank,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountingLib.Withdrawal(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountingLib.InsufficientFunds(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountingLib.deductFunds(AccountingLib.Bank,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountingLib.withdraw(AccountingLib.Bank,address,uint256)
		contract: AccountingLib | function: withdraw(AccountingLib.Bank,address,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'self.accountBalances[accountAddress] >= value', 'deductFunds(self,accountAddress,value)', '! accountAddress.send(value)', '! accountAddress.call.value(value)()']
[cfg_Reentrancy in] contract: AccountingLib . function: withdraw(AccountingLib.Bank,address,uint256) | Reentrancy\test110.sol#134-153
Start Contract GroveLib
	To analyze：GroveLib.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getNodeId(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getNodeValue(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getNodeHeight(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getNodeParent(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getNodeLeftChild(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getNodeRightChild(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getPreviousNode(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.getNextNode(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.insert(GroveLib.Index,bytes32,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.exists(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.remove(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._compare(int256,bytes2,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._getMaximum(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._getMinimum(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib.query(GroveLib.Index,bytes2,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._rebalanceTree(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._getBalanceFactor(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._updateNodeHeight(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._rotateLeft(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GroveLib._rotateRight(GroveLib.Index,bytes32)
		cfg分析安全，所以开始ICFG的分析
Start Contract ResourcePoolLib
	To analyze：ResourcePoolLib.createNextGeneration(ResourcePoolLib.Pool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.getGenerationForWindow(ResourcePoolLib.Pool,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.getNextGenerationId(ResourcePoolLib.Pool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.getCurrentGenerationId(ResourcePoolLib.Pool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.isInGeneration(ResourcePoolLib.Pool,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.isInCurrentGeneration(ResourcePoolLib.Pool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.isInNextGeneration(ResourcePoolLib.Pool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.isInPool(ResourcePoolLib.Pool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.AddedToGeneration(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.RemovedFromGeneration(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.canEnterPool(ResourcePoolLib.Pool,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.enterPool(ResourcePoolLib.Pool,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.canExitPool(ResourcePoolLib.Pool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.exitPool(ResourcePoolLib.Pool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.removeFromGeneration(ResourcePoolLib.Pool,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.deductFromBond(ResourcePoolLib.Pool,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.addToBond(ResourcePoolLib.Pool,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ResourcePoolLib.withdrawBond(ResourcePoolLib.Pool,address,uint256,uint256)
		contract: ResourcePoolLib | function: withdrawBond(ResourcePoolLib.Pool,address,uint256,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'value > self.bonds[resourceAddress]', 'None', 'isInPool(self,resourceAddress)', 'self.bonds[resourceAddress] - value < minimumBond', 'None', 'None', 'deductFromBond(self,resourceAddress,value)', '! resourceAddress.send(value)', '! resourceAddress.call.gas(msg.gas).value(value)()']
			path: ['entryPoint', 'value > self.bonds[resourceAddress]', 'None', 'isInPool(self,resourceAddress)', 'None', 'deductFromBond(self,resourceAddress,value)', '! resourceAddress.send(value)', '! resourceAddress.call.gas(msg.gas).value(value)()']
[cfg_Reentrancy in] contract: ResourcePoolLib . function: withdrawBond(ResourcePoolLib.Pool,address,uint256,uint256) | Reentrancy\test110.sol#1167-1195
Start Contract Relay
	To analyze：Relay.Relay()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Relay.relayCall(address,bytes4,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract ScheduledCallLib
	To analyze：ScheduledCallLib.getCallContractAddress(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallScheduledBy(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallCalledAtBlock(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallGracePeriod(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallTargetBlock(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallBaseGasPrice(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallGasPrice(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallGasUsed(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallABISignature(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.checkIfCalled(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.checkIfSuccess(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.checkIfCancelled(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallDataHash(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallPayout(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallFee(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.addAuthorization(ScheduledCallLib.CallDatabase,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.removeAuthorization(ScheduledCallLib.CallDatabase,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.checkAuthorization(ScheduledCallLib.CallDatabase,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallData(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getGenerationIdForCall(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getDesignatedCaller(ScheduledCallLib.CallDatabase,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.AwardedMissedBlockBonus(address,address,uint256,bytes32,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getMinimumBond()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.doBondBonusTransfer(ScheduledCallLib.CallDatabase,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.awardMissedBlockBonus(ScheduledCallLib.CallDatabase,address,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.DataRegistered(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.registerData(ScheduledCallLib.CallDatabase,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.CallExecuted(address,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.CallAborted(address,bytes32,bytes18)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.doCall(ScheduledCallLib.CallDatabase,bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallMaxCost(ScheduledCallLib.CallDatabase,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallFeeScalar(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.computeCallKey(address,address,bytes4,bytes32,uint256,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.CallScheduled(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.CallRejected(bytes32,bytes15)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getCallWindowSize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.getMinimumGracePeriod()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.scheduleCall(ScheduledCallLib.CallDatabase,address,address,bytes4,bytes32,uint256,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.CallCancelled(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ScheduledCallLib.cancelCall(ScheduledCallLib.CallDatabase,bytes32,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Alarm
	To analyze：Alarm.Alarm()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getAccountBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.deposit(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.unauthorizedAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.authorizedAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.addAuthorization(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.removeAuthorization(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.checkAuthorization(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getMinimumBond()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.depositBond()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.withdrawBond(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getBondBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getBondBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getGenerationForCall(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getGenerationSize(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getGenerationStartAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getGenerationEndAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCurrentGenerationId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getNextGenerationId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.isInPool()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.isInPool(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.isInGeneration(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.isInGeneration(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getPoolFreezePeriod()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getPoolOverlapSize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getPoolRotationDelay()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.canEnterPool()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.canEnterPool(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.canExitPool()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.canExitPool(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.enterPool()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.exitPool()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getLastCallKey()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallContractAddress(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallScheduledBy(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallCalledAtBlock(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallGracePeriod(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallTargetBlock(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallBaseGasPrice(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallGasPrice(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallGasUsed(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallABISignature(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.checkIfCalled(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.checkIfSuccess(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.checkIfCancelled(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallDataHash(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallPayout(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallFee(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallMaxCost(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallData(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.registerData()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getLastDataHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getLastDataLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getLastData()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.doCall(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getMinimumGracePeriod()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.scheduleCall(address,bytes4,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.scheduleCall(address,bytes4,bytes32,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.scheduleCall(address,bytes4,bytes32,uint256,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.cancelCall(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getCallWindowSize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getGenerationIdForCall(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getDesignatedCaller(bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getNextCall(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Alarm.getNextCallSibling(bytes32)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test110.sol
Start Contract SafeMath
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract ERC20Interface
Start Contract Owned
	To analyze：Owned.owned()
		cfg分析安全，所以开始ICFG的分析
Start Contract METADOLLAR
	To analyze：METADOLLAR.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.STARTMETADOLLAR()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.calculateTheEndPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkFrozenAccounts(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.sell2(address)
		contract: METADOLLAR | function: sell2(address) | accessPermision: False | 锁: True | 钱提前更新：True
			path: ['entryPoint', 'token = METADOLLAR(_tokenAddress)', 'tokens = msg.value * sellPrice', 'require(bool)(token.balanceOf(this) >= tokens)', 'commission = msg.value / commissionRate', 'require(bool)(address(this).send(commission))', 'token.transfer(msg.sender,tokens)']
[cfg_Reentrancy in] contract: METADOLLAR . function: sell2(address) | Reentrancy\test113.sol#219-226
	To analyze：METADOLLAR.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkMinimalGoal()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkPreIcoStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.buyToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.updatePrices()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setPreICOPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setICOPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setPrices(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setSellPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setCommissionRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.mintToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.destroyToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.collect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.stopThisIco(bool)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test113.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract BananaGame
	To analyze：BananaGame.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.BananaGame()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.safeSend(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.safeSend(address,uint256)
		contract: BananaGame | function: safeSend(address,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'value == 0', 'None', 'this.balance < value', 'None', '! (addr.call.gas(safeGas).value(value)())']
[cfg_Reentrancy in] contract: BananaGame . function: safeSend(address,uint256) | Reentrancy\test1169.sol#1220-1232
	To analyze：BananaGame.setStopped()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.setStarted()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBetNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changePercent(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.watchPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getPlayerBetResult(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: BananaGame | function: divest(address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invest >= investors[currentID].amountInvested)', 'invest -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != investorsNum', 'None', 'investorsNum --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invest >= investors[currentID].amountInvested)', 'invest -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != investorsNum', 'lastInvestor = investors[investorsNum]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[investorsNum]', 'None', 'investorsNum --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: BananaGame . function: divest(address) | Reentrancy\test1169.sol#1364-1389
	To analyze：BananaGame.addInvest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeInvestNum(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeDivestFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getInvestStatus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeORACLIZE_GAS_LIMIT(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getOraFee()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.getBetKey(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BananaGame.destroy()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1169.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1204.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy\test1236.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1236.sol
Start Contract ERC721
Start Contract PornstarsInterface
Start Contract PornSceneToken
	To analyze：PornSceneToken.PornSceneToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setPornstarsContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.createPromoScene(address,string,uint256[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.createContractScene(string,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.getScene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._paySceneStarOwners(PornSceneToken.Scene,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._payAwardOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._isGoodAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.starsOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._createScene(string,uint256[],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CryptoPornstarAward
	To analyze：CryptoPornstarAward.PornSceneToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setPornstarsContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.createPromoScene(address,string,uint256[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.createContractScene(string,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getScene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._paySceneStarOwners(PornSceneToken.Scene,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._payAwardOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._isGoodAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.starsOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._createScene(string,uint256[],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._triggerCooldown()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._isTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.rand(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCooldown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getAwardTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getCooldown()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.newAward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getCurrentAward()
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1294.sol
Start Contract DSMath
	To analyze：DSMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.imin(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.imax(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.wmul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.rmul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.wdiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.rdiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSMath.rpow(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TubInterface
Start Contract TokenInterface
Start Contract PepInterface
Start Contract OtcInterface
Start Contract SaiProxy
	To analyze：SaiProxy.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.imin(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.imax(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.wmul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.rmul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.wdiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.rdiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.rpow(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.open(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.give(address,bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.lock(address,bytes32)
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
		contract: SaiProxy | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value']
[cfg_Reentrancy in] contract: SaiProxy . function: lock(address,bytes32) | Reentrancy\test1314.sol#139-161
	To analyze：SaiProxy.draw(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.handleGovFee(TubInterface,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.wipe(address,bytes32,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.wipe(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.free(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.lockAndDraw(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxy | function: lockAndDraw(address,bytes32,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'lock(tub_,cup)', 'draw(tub_,cup,wad)', [['taint', 'draw(address,bytes32,uint256)'], ['eth', 'lock(address,bytes32)']]]
[Icfg_Reentrancy in] contract: SaiProxy . function: lockAndDraw(address,bytes32,uint256) | Reentrancy\test1314.sol#227-230
	To analyze：SaiProxy.lockAndDraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.wipeAndFree(address,bytes32,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.wipeAndFree(address,bytes32,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxy.shut(address,bytes32)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxy | function: shut(address,bytes32) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tub = TubInterface(tub_)', 'wipeAndFree(tub_,cup,rmul(tub.ink(cup),tub.per()),tub.tab(cup))', 'tub.shut(cup)', [['eth', 'wipeAndFree(address,bytes32,uint256,uint256)', 'free(address,bytes32,uint256)']]]
[Icfg_Reentrancy in] contract: SaiProxy . function: shut(address,bytes32) | Reentrancy\test1314.sol#247-251
	To analyze：SaiProxy.shut(address,bytes32,address)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxy | function: shut(address,bytes32,address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tub = TubInterface(tub_)', 'wipeAndFree(tub_,cup,rmul(tub.ink(cup),tub.per()),tub.tab(cup),otc_)', 'tub.shut(cup)', [['eth', 'wipeAndFree(address,bytes32,uint256,uint256,address)', 'free(address,bytes32,uint256)']]]
[Icfg_Reentrancy in] contract: SaiProxy . function: shut(address,bytes32,address) | Reentrancy\test1314.sol#253-257
Start Contract ProxyRegistryInterface
Start Contract SaiProxyCreateAndExecute
	To analyze：SaiProxyCreateAndExecute.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.imin(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.imax(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.wmul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.rmul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.wdiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.rdiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.rpow(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.open(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.give(address,bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.lock(address,bytes32)
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'None', 'tub.lock(cup,ink)']
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value', 'ink = ink - 1', 'None', 'tub.gem().allowance(this,tub) != uint256(- 1)', 'tub.gem().approve(tub,uint256(- 1))', 'None', 'tub.join(ink)', 'tub.skr().allowance(this,tub) != uint256(- 1)', 'tub.skr().approve(tub,uint256(- 1))', 'None', 'tub.lock(cup,ink)']
		contract: SaiProxyCreateAndExecute | function: lock(address,bytes32) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.value > 0', 'tub = TubInterface(tub_)', 'None', '(lad) = tub.cups(cup)', 'require(bool,string)(lad == address(this),cup-not-owned)', 'tub.gem().deposit.value(msg.value)()', 'ink = rdiv(msg.value,tub.per())', 'rmul(ink,tub.per()) <= msg.value']
[cfg_Reentrancy in] contract: SaiProxyCreateAndExecute . function: lock(address,bytes32) | Reentrancy\test1314.sol#139-161
	To analyze：SaiProxyCreateAndExecute.draw(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.handleGovFee(TubInterface,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.wipe(address,bytes32,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.wipe(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.free(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.lockAndDraw(address,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxyCreateAndExecute | function: lockAndDraw(address,bytes32,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'lock(tub_,cup)', 'draw(tub_,cup,wad)', [['taint', 'draw(address,bytes32,uint256)'], ['eth', 'lock(address,bytes32)']]]
[Icfg_Reentrancy in] contract: SaiProxyCreateAndExecute . function: lockAndDraw(address,bytes32,uint256) | Reentrancy\test1314.sol#227-230
	To analyze：SaiProxyCreateAndExecute.lockAndDraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.wipeAndFree(address,bytes32,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.wipeAndFree(address,bytes32,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.shut(address,bytes32)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxyCreateAndExecute | function: shut(address,bytes32) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tub = TubInterface(tub_)', 'wipeAndFree(tub_,cup,rmul(tub.ink(cup),tub.per()),tub.tab(cup))', 'tub.shut(cup)', [['eth', 'wipeAndFree(address,bytes32,uint256,uint256)', 'free(address,bytes32,uint256)']]]
[Icfg_Reentrancy in] contract: SaiProxyCreateAndExecute . function: shut(address,bytes32) | Reentrancy\test1314.sol#247-251
	To analyze：SaiProxyCreateAndExecute.shut(address,bytes32,address)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxyCreateAndExecute | function: shut(address,bytes32,address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'tub = TubInterface(tub_)', 'wipeAndFree(tub_,cup,rmul(tub.ink(cup),tub.per()),tub.tab(cup),otc_)', 'tub.shut(cup)', [['eth', 'wipeAndFree(address,bytes32,uint256,uint256,address)', 'free(address,bytes32,uint256)']]]
[Icfg_Reentrancy in] contract: SaiProxyCreateAndExecute . function: shut(address,bytes32,address) | Reentrancy\test1314.sol#253-257
	To analyze：SaiProxyCreateAndExecute.createAndOpen(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaiProxyCreateAndExecute.createOpenAndLock(address,address)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxyCreateAndExecute | function: createOpenAndLock(address,address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'proxy = ProxyRegistryInterface(registry_).build(msg.sender)', 'cup = open(tub_)', 'lock(tub_,cup)', 'TubInterface(tub_).give(cup,proxy)', []]
[Icfg_Reentrancy in] contract: SaiProxyCreateAndExecute . function: createOpenAndLock(address,address) | Reentrancy\test1314.sol#274-279
	To analyze：SaiProxyCreateAndExecute.createOpenLockAndDraw(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: SaiProxyCreateAndExecute | function: createOpenLockAndDraw(address,address,uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'proxy = ProxyRegistryInterface(registry_).build(msg.sender)', 'cup = open(tub_)', 'lockAndDraw(tub_,cup,wad)', 'TubInterface(tub_).give(cup,proxy)', []]
[Icfg_Reentrancy in] contract: SaiProxyCreateAndExecute . function: createOpenLockAndDraw(address,address,uint256) | Reentrancy\test1314.sol#282-287
./Reentrancy\test1314.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract StandardToken
	To analyze：StandardToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PowerCoin
	To analyze：PowerCoin.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.eT(address,uint256,uint256)
		contract: PowerCoin | function: eT(address,uint256,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'balances[msg.sender] = safeSub(balances[msg.sender],_tkA)', 'balances[_pd] = safeAdd(balances[_pd],_tkA)', '! _pd.call.value(_etA)()']
[cfg_Reentrancy in] contract: PowerCoin . function: eT(address,uint256,uint256) | Reentrancy\test1363.sol#130-136
	To analyze：PowerCoin.PowerCoin()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferAnyERC20Token(address,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1363.sol
Start Contract ERC20
Start Contract OraclesPresale
	To analyze：OraclesPresale.OraclesPresale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.set_saleAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.perform_withdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.refund_me()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.buy_the_tokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.upgrade_cap()
		cfg分析安全，所以开始ICFG的分析
	To analyze：OraclesPresale.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test142.sol
Start Contract REPOPAccessControl
	To analyze：REPOPAccessControl.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PullPayment
	To analyze：PullPayment.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PullPayment.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MetadataContract
	To analyze：MetadataContract.getMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._memcpy(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._toString(bytes32[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.getMetadataUrl(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.uintToBytes(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPERC721
	To analyze：REPOPERC721.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CarefulTransfer
	To analyze：CarefulTransfer.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MoneyManager
	To analyze：MoneyManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract RoundMoneyNicely
	To analyze：RoundMoneyNicely.roundMoneyDownNicely(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RoundMoneyNicely.roundMoneyUpToWholeFinney(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AuctionManager
	To analyze：AuctionManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.AuctionManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllActiveAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.createAuction(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.bid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.endAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.requiredBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuctionStartBid()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setAuctionStartBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MarketManager
	To analyze：MarketManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.MarketManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllActiveSales()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllSalesByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.purchasePop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellPop(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.cancelSellPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.changeSellPOPPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract CloningInterface
Start Contract GenesMarket
	To analyze：GenesMarket.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.GenesMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.startSellingGenes(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.stopSellingGenes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.useBottle(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.purchaseGenes(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSaleBySeller(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getAmountOfGene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getMyGenes()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.changeSellGenesPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPCore
	To analyze：REPOPCore.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.REPOPCore()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setAuctionManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getAuctionManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMarketManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getMarketManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGeneScienceAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGenesMarketAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGenesMarketAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellPop(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellGenes(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnerInAnyPlatformById(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopName(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.removeCooldown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._ownerOfPopInAnyPlatform(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnershipForCloning(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.changeRefresherFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithTwoPops(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithPopAndBottle(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1472.sol
Start Contract ERC20
Start Contract Ownable
	To analyze：Ownable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC827
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Token
	To analyze：ERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC827Token
	To analyze：ERC827Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.approveAndCall(address,uint256,bytes)
		contract: ERC827Token | function: approveAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.approve(_spender,_value)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: approveAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#344-361
	To analyze：ERC827Token.transferAndCall(address,uint256,bytes)
		contract: ERC827Token | function: transferAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transfer(_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: transferAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#373-388
	To analyze：ERC827Token.transferFromAndCall(address,address,uint256,bytes)
		contract: ERC827Token | function: transferFromAndCall(address,address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transferFrom(_from,_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: transferFromAndCall(address,address,uint256,bytes) | Reentrancy\test1487.sol#401-415
	To analyze：ERC827Token.increaseApprovalAndCall(address,uint256,bytes)
		contract: ERC827Token | function: increaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.increaseApproval(_spender,_addedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: increaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#430-446
	To analyze：ERC827Token.decreaseApprovalAndCall(address,uint256,bytes)
		contract: ERC827Token | function: decreaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.decreaseApproval(_spender,_subtractedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: decreaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#461-477
Start Contract PauseBurnableERC827Token
	To analyze：PauseBurnableERC827Token.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.approveAndCall(address,uint256,bytes)
		contract: PauseBurnableERC827Token | function: approveAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.approve(_spender,_value)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: PauseBurnableERC827Token . function: approveAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#344-361
	To analyze：PauseBurnableERC827Token.transferAndCall(address,uint256,bytes)
		contract: PauseBurnableERC827Token | function: transferAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transfer(_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: PauseBurnableERC827Token . function: transferAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#373-388
	To analyze：PauseBurnableERC827Token.transferFromAndCall(address,address,uint256,bytes)
		contract: PauseBurnableERC827Token | function: transferFromAndCall(address,address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transferFrom(_from,_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: PauseBurnableERC827Token . function: transferFromAndCall(address,address,uint256,bytes) | Reentrancy\test1487.sol#401-415
	To analyze：PauseBurnableERC827Token.increaseApprovalAndCall(address,uint256,bytes)
		contract: PauseBurnableERC827Token | function: increaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.increaseApproval(_spender,_addedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: PauseBurnableERC827Token . function: increaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#430-446
	To analyze：PauseBurnableERC827Token.decreaseApprovalAndCall(address,uint256,bytes)
		contract: PauseBurnableERC827Token | function: decreaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.decreaseApproval(_spender,_subtractedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: PauseBurnableERC827Token . function: decreaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#461-477
	To analyze：PauseBurnableERC827Token.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.transferPauseOperator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token._burn(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PauseBurnableERC827Token.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BQT
	To analyze：BQT.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.approveAndCall(address,uint256,bytes)
		contract: BQT | function: approveAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.approve(_spender,_value)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: BQT . function: approveAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#344-361
	To analyze：BQT.transferAndCall(address,uint256,bytes)
		contract: BQT | function: transferAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transfer(_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: BQT . function: transferAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#373-388
	To analyze：BQT.transferFromAndCall(address,address,uint256,bytes)
		contract: BQT | function: transferFromAndCall(address,address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transferFrom(_from,_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: BQT . function: transferFromAndCall(address,address,uint256,bytes) | Reentrancy\test1487.sol#401-415
	To analyze：BQT.increaseApprovalAndCall(address,uint256,bytes)
		contract: BQT | function: increaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.increaseApproval(_spender,_addedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: BQT . function: increaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#430-446
	To analyze：BQT.decreaseApprovalAndCall(address,uint256,bytes)
		contract: BQT | function: decreaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.decreaseApproval(_spender,_subtractedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: BQT . function: decreaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test1487.sol#461-477
	To analyze：BQT.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.transferPauseOperator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT._burn(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BQT.constructor()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1487.sol
Start Contract REPOPAccessControl
	To analyze：REPOPAccessControl.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PullPayment
	To analyze：PullPayment.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PullPayment.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MetadataContract
	To analyze：MetadataContract.getMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._memcpy(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._toString(bytes32[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.getMetadataUrl(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.uintToBytes(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPERC721
	To analyze：REPOPERC721.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CarefulTransfer
	To analyze：CarefulTransfer.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MoneyManager
	To analyze：MoneyManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract RoundMoneyNicely
	To analyze：RoundMoneyNicely.roundMoneyDownNicely(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RoundMoneyNicely.roundMoneyUpToWholeFinney(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AuctionManager
	To analyze：AuctionManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.AuctionManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllActiveAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.createAuction(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.bid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.endAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.requiredBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuctionStartBid()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setAuctionStartBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MarketManager
	To analyze：MarketManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.MarketManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllActiveSales()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllSalesByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.purchasePop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellPop(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.cancelSellPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.changeSellPOPPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract CloningInterface
Start Contract GenesMarket
	To analyze：GenesMarket.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.GenesMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.startSellingGenes(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.stopSellingGenes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.useBottle(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.purchaseGenes(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSaleBySeller(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getAmountOfGene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getMyGenes()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.changeSellGenesPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPCore
	To analyze：REPOPCore.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.REPOPCore()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setAuctionManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getAuctionManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMarketManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getMarketManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGeneScienceAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGenesMarketAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGenesMarketAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellPop(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellGenes(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnerInAnyPlatformById(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopName(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.removeCooldown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._ownerOfPopInAnyPlatform(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnershipForCloning(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.changeRefresherFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithTwoPops(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithPopAndBottle(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test153.sol
Start Contract DAO
Start Contract WithdrawDAO
	To analyze：WithdrawDAO.withdraw()
		contract: WithdrawDAO | function: withdraw() | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'balance = mainDAO.balanceOf(msg.sender)', '! mainDAO.transferFrom(msg.sender,this,balance) || ! msg.sender.send(balance)']
[cfg_Reentrancy in] contract: WithdrawDAO . function: withdraw() | Reentrancy\test1541.sol#15-20
	To analyze：WithdrawDAO.clawback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1541.sol
Start Contract AddressLottery
	To analyze：AddressLottery.AddressLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.participate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.luckyNumberOfAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.reseed(AddressLottery.SeedComponents)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.forceReseed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1559.sol
Start Contract Ownable
	To analyze：Ownable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20SafeTransfer
	To analyze：ERC20SafeTransfer.safeTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20SafeTransfer.safeTransferFrom(address,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20SafeTransfer.safeApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20SafeTransfer.fetchReturnData()
		cfg分析安全，所以开始ICFG的分析
Start Contract Withdrawable
	To analyze：Withdrawable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.withdrawETH(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract TokenTransferProxy
	To analyze：TokenTransferProxy.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.addAuthorizedAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.removeAuthorizedAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.transferFrom(address,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.getAuthorizedAddresses()
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.paused()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Utils
	To analyze：Utils.precision()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_qty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_rate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.eth_decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_uint()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.getDecimals(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.tokenAllowanceAndBalanceSet(address,address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcDstQty(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcSrcQty(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcDestAmount(ERC20,ERC20,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcSrcAmount(ERC20,ERC20,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcRateFromQty(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ErrorReporter
	To analyze：ErrorReporter.revertTx(string)
		cfg分析安全，所以开始ICFG的分析
Start Contract Affiliate
	To analyze：Affiliate.init(address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Affiliate.payout()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Affiliate.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Affiliate.getTotalFeePercentage()
		cfg分析安全，所以开始ICFG的分析
Start Contract AffiliateRegistry
	To analyze：AffiliateRegistry.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.constructor(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.registerAffiliate(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.overrideRegisterAffiliate(address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.deleteAffiliate(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.createClone()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.isValidAffiliate(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.updateCompanyInfo(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TotleControl
	To analyze：TotleControl.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.addTotle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.removeTotle(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SelectorProvider
Start Contract ExchangeHandler
	To analyze：ExchangeHandler.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.paused()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.withdrawETH(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.addTotle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.removeTotle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.getAmountToGive(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.staticExchangeChecks(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.performBuyOrder(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.performSellOrder(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TotlePrimary
	To analyze：TotlePrimary.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.paused()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.withdrawETH(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.constructor(address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.updateDefaultFeeAccount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.addHandlerToWhitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.removeHandlerFromWhitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.performRebalance(TotlePrimary.Trade[],address,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.staticChecks(TotlePrimary.Trade[],TotlePrimary.TradeFlag[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.initialiseTradeFlags(TotlePrimary.Trade[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.transferTokensToUser(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.performTrade(TotlePrimary.Trade,TotlePrimary.TradeFlag,TotlePrimary.CurrentAmounts)
		contract: TotlePrimary | function: performTrade(TotlePrimary.Trade,TotlePrimary.TradeFlag,TotlePrimary.CurrentAmounts) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'None', 'None', 'j < trade.orders.length', 'amounts.amountLeftToSpendOnTrade * 10000 < (amounts.amountSpentOnTrade + amounts.amountLeftToSpendOnTrade)', 'None', 'trade.isSell', '(amounts.amountSpentOnTrade) >= trade.tokenAmount', 'None', 'None', 'tradeFlag.ignoreOrder[j] || amounts.amountLeftToSpendOnTrade == 0', 'None', 'amountSpentOnOrder = 0', 'amountReceivedFromOrder = 0', 'thisOrder = trade.orders[j]', 'thisHandler = ExchangeHandler(thisOrder.exchangeHandler)', 'amountToGiveForOrder = Utils.min(thisHandler.getAmountToGive(thisOrder.genericPayload),amounts.amountLeftToSpendOnTrade)', 'amountToGiveForOrder == 0', 'None', '! thisHandler.staticExchangeChecks(thisOrder.genericPayload)', 'None', 'trade.isSell', '(amountSpentOnOrder,amountReceivedFromOrder) = thisHandler.performBuyOrder.value(amountToGiveForOrder)(thisOrder.genericPayload,amountToGiveForOrder)']
			path: ['entryPoint', 'None', 'None', 'j < trade.orders.length', 'amounts.amountLeftToSpendOnTrade * 10000 < (amounts.amountSpentOnTrade + amounts.amountLeftToSpendOnTrade)', 'None', 'trade.isSell', '(amounts.amountReceivedFromTrade) >= trade.tokenAmount', 'None', 'None', 'tradeFlag.ignoreOrder[j] || amounts.amountLeftToSpendOnTrade == 0', 'None', 'amountSpentOnOrder = 0', 'amountReceivedFromOrder = 0', 'thisOrder = trade.orders[j]', 'thisHandler = ExchangeHandler(thisOrder.exchangeHandler)', 'amountToGiveForOrder = Utils.min(thisHandler.getAmountToGive(thisOrder.genericPayload),amounts.amountLeftToSpendOnTrade)', 'amountToGiveForOrder == 0', 'None', '! thisHandler.staticExchangeChecks(thisOrder.genericPayload)', 'None', 'trade.isSell', '(amountSpentOnOrder,amountReceivedFromOrder) = thisHandler.performBuyOrder.value(amountToGiveForOrder)(thisOrder.genericPayload,amountToGiveForOrder)']
[cfg_Reentrancy in] contract: TotlePrimary . function: performTrade(TotlePrimary.Trade,TotlePrimary.TradeFlag,TotlePrimary.CurrentAmounts) | Reentrancy\test1645.sol#1215-1307
	To analyze：TotlePrimary.checkIfTradeAmountsAcceptable(TotlePrimary.Trade,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.transferTokens(TotlePrimary.Trade[],TotlePrimary.TradeFlag[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.calculateMaxEtherSpend(TotlePrimary.Trade,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.calculateFee(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.removeFee(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1645.sol
Start Contract DAO
Start Contract untrustedChildWithdraw
	To analyze：untrustedChildWithdraw.untrustedChildWithdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：untrustedChildWithdraw.requiredEndowment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：untrustedChildWithdraw.withdraw(uint256)
		contract: untrustedChildWithdraw | function: withdraw(uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'balance = whiteList[proposalId].dao.balanceOf(msg.sender)', 'adjustedBalance = balance * (whiteList[proposalId].numerator / ratioDenominator)', '! whiteList[proposalId].dao.transferFrom(msg.sender,this,balance) || ! msg.sender.send(adjustedBalance)']
[cfg_Reentrancy in] contract: untrustedChildWithdraw . function: withdraw(uint256) | Reentrancy\test1672.sol#56-64
./Reentrancy\test1672.sol
Start Contract ERC20
Start Contract EnjinBuyer
	To analyze：EnjinBuyer.set_token(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.set_refunded(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.activate_kill_switch(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.personal_withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.withdraw(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.purchase_tokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1698.sol
Start Contract ContractReceiver
Start Contract PrivateSale
	To analyze：PrivateSale.constructor(address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.getMinContrib()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.setMinContrib(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.setLockend1(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.setLockend2(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.setLockRatio(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.remaining()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.withdrawTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.tokenFallback(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateSale.fallback()
		cfg分析安全，所以开始ICFG的分析
		contract: PrivateSale | function: fallback() | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'require(bool)(now < end && msg.value >= mincontrib)', 'owner.transfer(msg.value)', 'toks = msg.value.mul(rate)', 'Contribution(msg.sender,msg.value,toks)', 'toks1 = toks.div(denominator).mul(numerator)', 'toks2 = toks - toks1', 'data = escrow.transactionRawToBytes(toks1,msg.sender,lockend1,true,false)', 'data2 = escrow.transactionRawToBytes(toks2,msg.sender,lockend2,true,false)', 'tokContract.transfer(escrow,toks1,data)', 'tokContract.transfer(escrow,toks2,data2)', [['taint', 'transfer(address,uint256,bytes)', 'transferToContract(address,uint256,bytes)']]]
		contract: PrivateSale | function: fallback() | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'require(bool)(now < end && msg.value >= mincontrib)', 'owner.transfer(msg.value)', 'toks = msg.value.mul(rate)', 'Contribution(msg.sender,msg.value,toks)', 'toks1 = toks.div(denominator).mul(numerator)', 'toks2 = toks - toks1', 'data = escrow.transactionRawToBytes(toks1,msg.sender,lockend1,true,false)', 'data2 = escrow.transactionRawToBytes(toks2,msg.sender,lockend2,true,false)', 'tokContract.transfer(escrow,toks1,data)', [['taint', 'transfer(address,uint256,bytes)', 'transferToContract(address,uint256,bytes)']]]
[Icfg_Reentrancy in] contract: PrivateSale . function: fallback() | Reentrancy\test18.sol#95-124
Start Contract ERC20Interface
Start Contract StandardERC20
	To analyze：StandardERC20.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardERC20.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardERC20.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardERC20.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardERC20.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardERC20.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardERC20.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardERC20.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Token
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferToAddress(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferToContract(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.setBurnable(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token._burn(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Array256Lib
	To analyze：Array256Lib.sumElements(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Array256Lib.getMax(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Array256Lib.getMin(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Array256Lib.indexOf(uint256[],uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Array256Lib.getParentI(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Array256Lib.getLeftChildI(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Array256Lib.heapSort(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Array256Lib.uniq(uint256[])
		cfg分析安全，所以开始ICFG的分析
Start Contract BytesToTypes
	To analyze：BytesToTypes.bytesToAddress(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToBool(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.getStringSize(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToString(uint256,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToBytes32(uint256,bytes,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt8(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt16(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt24(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt32(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt40(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt48(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt56(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt64(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt72(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt80(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt88(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt96(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt104(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt112(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt120(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt128(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt136(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt144(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt152(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt160(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt168(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt176(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt184(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt192(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt200(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt208(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt216(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt224(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt232(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt240(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt248(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToInt256(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint8(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint16(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint24(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint32(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint40(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint48(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint56(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint64(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint72(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint80(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint88(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint96(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint104(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint112(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint120(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint128(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint136(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint144(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint152(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint160(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint168(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint176(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint184(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint192(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint200(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint208(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint216(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint224(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint232(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint240(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint248(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BytesToTypes.bytesToUint256(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SizeOf
	To analyze：SizeOf.sizeOfString(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SizeOf.sizeOfInt(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SizeOf.sizeOfUint(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SizeOf.sizeOfAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SizeOf.sizeOfBool()
		cfg分析安全，所以开始ICFG的分析
Start Contract TypesToBytes
	To analyze：TypesToBytes.TypesToBytes()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TypesToBytes.addressToBytes(uint256,address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TypesToBytes.bytes32ToBytes(uint256,bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TypesToBytes.boolToBytes(uint256,bool,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TypesToBytes.stringToBytes(uint256,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TypesToBytes.intToBytes(uint256,int256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TypesToBytes.uintToBytes(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract Seriality
	To analyze：Seriality.sizeOfString(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.sizeOfInt(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.sizeOfUint(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.sizeOfAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.sizeOfBool()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.TypesToBytes()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.addressToBytes(uint256,address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytes32ToBytes(uint256,bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.boolToBytes(uint256,bool,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.stringToBytes(uint256,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.intToBytes(uint256,int256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.uintToBytes(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToAddress(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToBool(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.getStringSize(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToString(uint256,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToBytes32(uint256,bytes,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt8(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt16(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt24(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt32(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt40(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt48(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt56(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt64(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt72(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt80(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt88(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt96(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt104(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt112(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt120(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt128(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt136(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt144(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt152(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt160(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt168(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt176(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt184(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt192(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt200(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt208(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt216(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt224(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt232(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt240(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt248(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToInt256(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint8(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint16(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint24(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint32(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint40(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint48(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint56(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint64(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint72(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint80(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint88(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint96(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint104(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint112(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint120(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint128(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint136(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint144(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint152(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint160(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint168(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint176(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint184(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint192(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint200(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint208(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint216(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint224(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint232(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint240(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint248(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.bytesToUint256(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Seriality.Seriality()
		cfg分析安全，所以开始ICFG的分析
Start Contract TimedEscrow
	To analyze：TimedEscrow.sizeOfString(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.sizeOfInt(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.sizeOfUint(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.sizeOfAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.sizeOfBool()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.TypesToBytes()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.addressToBytes(uint256,address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytes32ToBytes(uint256,bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.boolToBytes(uint256,bool,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.stringToBytes(uint256,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.intToBytes(uint256,int256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.uintToBytes(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToAddress(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToBool(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.getStringSize(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToString(uint256,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToBytes32(uint256,bytes,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt8(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt16(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt24(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt32(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt40(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt48(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt56(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt64(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt72(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt80(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt88(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt96(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt104(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt112(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt120(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt128(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt136(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt144(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt152(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt160(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt168(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt176(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt184(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt192(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt200(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt208(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt216(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt224(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt232(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt240(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt248(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToInt256(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint8(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint16(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint24(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint32(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint40(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint48(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint56(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint64(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint72(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint80(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint88(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint96(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint104(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint112(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint120(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint128(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint136(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint144(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint152(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint160(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint168(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint176(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint184(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint192(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint200(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint208(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint216(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint224(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint232(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint240(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint248(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.bytesToUint256(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.Seriality()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.addTransaction(TimedEscrow.Transaction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.voidTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.getTransactionIdsOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.getTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.performTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.transactionStructFromBytesSeriality(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.transactionStructToBytesSeriality(TimedEscrow.Transaction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.transactionRawToBytes(uint256,address,uint256,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.tokenFallback(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedEscrow.rescheduleTransaction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test18.sol
Start Contract WhaleGiveaway1
	To analyze：WhaleGiveaway1.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.redeem()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1885.sol
Start Contract WhaleGiveaway1
	To analyze：WhaleGiveaway1.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.GetFreebie()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway1.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1911.sol
Start Contract PrivateDeposit
	To analyze：PrivateDeposit.PrivateDeposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateDeposit.setLog(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateDeposit.Deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateDeposit.CashOut(uint256)
		contract: PrivateDeposit | function: CashOut(uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_am <= balances[msg.sender]', 'msg.sender.call.value(_am)()']
[cfg_Reentrancy in] contract: PrivateDeposit . function: CashOut(uint256) | Reentrancy\test1916.sol#41-51
	To analyze：PrivateDeposit.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract Log
	To analyze：Log.AddMessage(address,uint256,string)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1916.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract DividendDistributor
	To analyze：DividendDistributor.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.PrivateInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.loggedTransfer(uint256,bytes32,address,address)
		contract: DividendDistributor | function: loggedTransfer(uint256,bytes32,address,address) | accessPermision: True | publicCaller: True | 锁: False | 钱提前更新：False
			path: ['entryPoint', '! target.call.value(amount)()']
[cfg_Reentrancy in] contract: DividendDistributor . function: loggedTransfer(uint256,bytes32,address,address) | Reentrancy\test1928.sol#51-56
	To analyze：DividendDistributor.invest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.divest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.calculateDividend()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.getInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.payDividend()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.distributeDividends()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.doTransfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.setMinInvestment(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributor.destroy()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1928.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy\test1948.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1948.sol
Start Contract Owned
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenRecipient
Start Contract TokenERC20
	To analyze：TokenERC20.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinToken
	To analyze：MifflinToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: MifflinToken . function: contribution(uint256) | Reentrancy\test1950.sol#216-233
	To analyze：MifflinToken.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BeetBuck
	To analyze：BeetBuck.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: BeetBuck . function: contribution(uint256) | Reentrancy\test1950.sol#216-233
	To analyze：BeetBuck.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.BeetBuck(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NapNickel
	To analyze：NapNickel.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NapNickel . function: contribution(uint256) | Reentrancy\test1950.sol#216-233
	To analyze：NapNickel.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.NapNickel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isLeapYear(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.leapYearsBefore(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDaysInMonth(uint8,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestampParts(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestamp(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getYear(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMonth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDay(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getHour(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMinute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getSecond(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getWeekday(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract QuabityQuarter
	To analyze：QuabityQuarter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: QuabityQuarter . function: contribution(uint256) | Reentrancy\test1950.sol#216-233
	To analyze：QuabityQuarter.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.QuabityQuarter(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract KelevinKoin
	To analyze：KelevinKoin.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: KelevinKoin . function: contribution(uint256) | Reentrancy\test1950.sol#216-233
	To analyze：KelevinKoin.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.KelevinKoin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NnexNote
	To analyze：NnexNote.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NnexNote . function: contribution(uint256) | Reentrancy\test1950.sol#216-233
	To analyze：NnexNote.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.NnexNote(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract DundieDollar
	To analyze：DundieDollar.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: DundieDollar . function: contribution(uint256) | Reentrancy\test1950.sol#216-233
	To analyze：DundieDollar.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.DundieDollar(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addAward(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardBalanceOf(address,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardName(uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinMarket
	To analyze：MifflinMarket.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.MifflinMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setToken(uint8,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeToken(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setActive(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getRewardToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenById(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensByAddress(uint256,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensById(uint256,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.highContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.lowContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1950.sol
Start Contract Owned
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenRecipient
Start Contract TokenERC20
	To analyze：TokenERC20.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinToken
	To analyze：MifflinToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: MifflinToken . function: contribution(uint256) | Reentrancy\test1991.sol#216-233
	To analyze：MifflinToken.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BeetBuck
	To analyze：BeetBuck.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: BeetBuck . function: contribution(uint256) | Reentrancy\test1991.sol#216-233
	To analyze：BeetBuck.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.BeetBuck(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NapNickel
	To analyze：NapNickel.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NapNickel . function: contribution(uint256) | Reentrancy\test1991.sol#216-233
	To analyze：NapNickel.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.NapNickel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isLeapYear(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.leapYearsBefore(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDaysInMonth(uint8,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestampParts(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestamp(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getYear(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMonth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDay(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getHour(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMinute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getSecond(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getWeekday(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract QuabityQuarter
	To analyze：QuabityQuarter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: QuabityQuarter . function: contribution(uint256) | Reentrancy\test1991.sol#216-233
	To analyze：QuabityQuarter.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.QuabityQuarter(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract KelevinKoin
	To analyze：KelevinKoin.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: KelevinKoin . function: contribution(uint256) | Reentrancy\test1991.sol#216-233
	To analyze：KelevinKoin.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.KelevinKoin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NnexNote
	To analyze：NnexNote.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NnexNote . function: contribution(uint256) | Reentrancy\test1991.sol#216-233
	To analyze：NnexNote.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.NnexNote(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract DundieDollar
	To analyze：DundieDollar.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: DundieDollar . function: contribution(uint256) | Reentrancy\test1991.sol#216-233
	To analyze：DundieDollar.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.DundieDollar(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addAward(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardBalanceOf(address,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardName(uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinMarket
	To analyze：MifflinMarket.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.MifflinMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setToken(uint8,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeToken(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setActive(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getRewardToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenById(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensByAddress(uint256,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensById(uint256,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.highContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.lowContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test1991.sol
Start Contract AmIOnTheFork
Start Contract ReplaySafeSplit
	To analyze：ReplaySafeSplit.split(address,address)
		contract: ReplaySafeSplit | function: split(address,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'amIOnTheFork.forked() && targetFork.send(msg.value)']
		contract: ReplaySafeSplit | function: split(address,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'amIOnTheFork.forked() && targetFork.send(msg.value)', '! amIOnTheFork.forked() && targetNoFork.send(msg.value)']
[cfg_Reentrancy in] contract: ReplaySafeSplit . function: split(address,address) | Reentrancy\test2014.sol#13-20
	To analyze：ReplaySafeSplit.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2014.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherheroStabilizationFund
	To analyze：EtherheroStabilizationFund.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.ReturnEthToEtherhero()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherhero
	To analyze：Etherhero.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.insertBeneficiaries(address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.getBeneficiaries(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.calculationOfPayment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.receivePercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.makeDeposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2022.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract ERC20
Start Contract IMultiToken
Start Contract BancorBuyer
	To analyze：BancorBuyer.sumWeightOfMultiToken(IMultiToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorBuyer.deposit(address,address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorBuyer.withdraw(address,uint256,address[],uint256[])
		contract: BancorBuyer | function: withdraw(address,uint256,address[],uint256[]) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_value > 0', '_to.transfer(_value)', 'balances[msg.sender] = balances[msg.sender].sub(_value)', 'None', 'i = 0', 'None', 'i < _tokens.length', 'token = ERC20(_tokens[i])', 'tokenValue = _tokenValues[i]', 'tokenBalance = token.balanceOf(this)']
		contract: BancorBuyer | function: withdraw(address,uint256,address[],uint256[]) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_value > 0', '_to.transfer(_value)', 'balances[msg.sender] = balances[msg.sender].sub(_value)', 'None', 'i = 0', 'None', 'i < _tokens.length', 'token = ERC20(_tokens[i])', 'tokenValue = _tokenValues[i]', 'tokenBalance = token.balanceOf(this)', 'token.transfer(_to,tokenValue)']
		contract: BancorBuyer | function: withdraw(address,uint256,address[],uint256[]) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_value > 0', '_to.transfer(_value)', 'balances[msg.sender] = balances[msg.sender].sub(_value)', 'None', 'i = 0', 'None', 'i < _tokens.length', 'token = ERC20(_tokens[i])', 'tokenValue = _tokenValues[i]', 'tokenBalance = token.balanceOf(this)', 'token.transfer(_to,tokenValue)', 'require(bool)(token.balanceOf(this) == tokenBalance.sub(tokenValue))']
[cfg_Reentrancy in] contract: BancorBuyer . function: withdraw(address,uint256,address[],uint256[]) | Reentrancy\test2073.sol#135-150
	To analyze：BancorBuyer.buyOne(ERC20,address,uint256,bytes)
		contract: BancorBuyer | function: buyOne(ERC20,address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'balances[msg.sender] = balances[msg.sender].add(msg.value)', 'tokenBalance = token.balanceOf(this)', 'require(bool)(_exchange.call.value(_value)(_data))']
		contract: BancorBuyer | function: buyOne(ERC20,address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'balances[msg.sender] = balances[msg.sender].add(msg.value)', 'tokenBalance = token.balanceOf(this)', 'require(bool)(_exchange.call.value(_value)(_data))', 'balances[msg.sender] = balances[msg.sender].sub(_value)', 'tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance))']
[cfg_Reentrancy in] contract: BancorBuyer . function: buyOne(ERC20,address,uint256,bytes) | Reentrancy\test2073.sol#175-190
	To analyze：BancorBuyer.buy1(address[],address[],uint256[],bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorBuyer.buy2(address[],address[],uint256[],bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: BancorBuyer | function: buy2(address[],address[],uint256[],bytes,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'balances[msg.sender] = balances[msg.sender].add(msg.value)', 'this.buyOne(ERC20(_tokens[0]),_exchanges[0],_values[0],_data1)', 'this.buyOne(ERC20(_tokens[1]),_exchanges[1],_values[1],_data2)', [['taint', 'buyOne(ERC20,address,uint256,bytes)'], ['eth', 'buyOne(ERC20,address,uint256,bytes)'], ['eth', 'buyOne(ERC20,address,uint256,bytes)']]]
[Icfg_Reentrancy in] contract: BancorBuyer . function: buy2(address[],address[],uint256[],bytes,bytes) | Reentrancy\test2073.sol#205-218
	To analyze：BancorBuyer.buy3(address[],address[],uint256[],bytes,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
		contract: BancorBuyer | function: buy3(address[],address[],uint256[],bytes,bytes,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'balances[msg.sender] = balances[msg.sender].add(msg.value)', 'this.buyOne(ERC20(_tokens[0]),_exchanges[0],_values[0],_data1)', 'this.buyOne(ERC20(_tokens[1]),_exchanges[1],_values[1],_data2)', [['taint', 'buyOne(ERC20,address,uint256,bytes)'], ['eth', 'buyOne(ERC20,address,uint256,bytes)'], ['eth', 'buyOne(ERC20,address,uint256,bytes)']]]
		contract: BancorBuyer | function: buy3(address[],address[],uint256[],bytes,bytes,bytes) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'balances[msg.sender] = balances[msg.sender].add(msg.value)', 'this.buyOne(ERC20(_tokens[0]),_exchanges[0],_values[0],_data1)', 'this.buyOne(ERC20(_tokens[1]),_exchanges[1],_values[1],_data2)', 'this.buyOne(ERC20(_tokens[2]),_exchanges[2],_values[2],_data3)', [['taint', 'buyOne(ERC20,address,uint256,bytes)'], ['eth', 'buyOne(ERC20,address,uint256,bytes)'], ['eth', 'buyOne(ERC20,address,uint256,bytes)'], ['eth', 'buyOne(ERC20,address,uint256,bytes)']]]
[Icfg_Reentrancy in] contract: BancorBuyer . function: buy3(address[],address[],uint256[],bytes,bytes,bytes) | Reentrancy\test2073.sol#220-235
./Reentrancy\test2073.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract StandardToken
	To analyze：StandardToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PowerCoin
	To analyze：PowerCoin.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.sAssert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.eT(address,uint256,uint256)
		contract: PowerCoin | function: eT(address,uint256,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'balances[msg.sender] = safeSub(balances[msg.sender],_tkA)', 'balances[_pd] = safeAdd(balances[_pd],_tkA)', '! _pd.call.value(_etA)()']
[cfg_Reentrancy in] contract: PowerCoin . function: eT(address,uint256,uint256) | Reentrancy\test2092.sol#130-136
	To analyze：PowerCoin.PowerCoin()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PowerCoin.transferAnyERC20Token(address,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2092.sol
Start Contract ERC20
Start Contract ICOSyndicate
	To analyze：ICOSyndicate.set_addresses(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.activate_kill_switch()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.withdraw(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ICOSyndicate.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2153.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract tokenRecipient
Start Contract NamiCrowdSale
	To analyze：NamiCrowdSale.NamiCrowdSale(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferForTeam(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeTransferable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinary(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinaryAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.getPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.burnTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setPresalePhase(NamiCrowdSale.Phase)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setCrowdsaleManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateForInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToBuyer(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BinaryOption
	To analyze：BinaryOption.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.BinaryOption(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeOneSession(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getChooses()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.resetSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.openSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.invest(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getEtherToBuy(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeSession(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PresaleToken
Start Contract ERC223ReceivingContract
Start Contract NamiExchange
	To analyze：NamiExchange.NamiExchange(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallback(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.placeBuyOrder(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallbackBuyer(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeBidOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallbackExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeAskOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.buyNac(address)
		contract: NamiExchange | function: buyNac(address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)', 'asset = ERC23(NamiAddr)', 'maxEth = (ask[_seller].volume).div(ask[_seller].price)', 'msg.value > maxEth', '_seller.send(maxEth) && msg.sender.send(msg.value.sub(maxEth)) && asset.transfer(msg.sender,ask[_seller].volume)']
		contract: NamiExchange | function: buyNac(address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)', 'asset = ERC23(NamiAddr)', 'maxEth = (ask[_seller].volume).div(ask[_seller].price)', 'msg.value > maxEth', '_seller.send(msg.value) && asset.transfer(msg.sender,(msg.value).mul(ask[_seller].price))']
[cfg_Reentrancy in] contract: NamiExchange . function: buyNac(address) | Reentrancy\test2168.sol#1007-1033
Start Contract ERC23
Start Contract NamiMultiSigWallet
	To analyze：NamiMultiSigWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.NamiMultiSigWallet(address[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.replaceOwner(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.changeRequirement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.submitTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.confirmTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.revokeConfirmation(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.executeTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.isConfirmed(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmationCount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionCount(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getOwners()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmations(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionIds(uint256,uint256,bool,bool)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2168.sol
Start Contract SysEscrow
	To analyze：SysEscrow.SysEscrow()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SysEscrow.createEscrow(bytes16,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SysEscrow.setArbitrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SysEscrow.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SysEscrow.cancelEscrow(bytes16,address,address,uint256)
		contract: SysEscrow | function: cancelEscrow(bytes16,address,address,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_tradeHash = keccak256()(_tradeID,_seller,_buyer,_value)', 'require(bool)(escrows[_tradeHash].exists)', 'require(bool)(escrows[_tradeHash].buyerCanCancelAfter < now)', 'arbitratorValue = escrows[_tradeHash].summ * ARBITRATOR_PERCENT / 100', 'buyerValue = escrows[_tradeHash].summ - arbitratorValue', 'buyerReceivedMoney = escrows[_tradeHash].buyer.call.value(buyerValue)()']
		contract: SysEscrow | function: cancelEscrow(bytes16,address,address,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_tradeHash = keccak256()(_tradeID,_seller,_buyer,_value)', 'require(bool)(escrows[_tradeHash].exists)', 'require(bool)(escrows[_tradeHash].buyerCanCancelAfter < now)', 'arbitratorValue = escrows[_tradeHash].summ * ARBITRATOR_PERCENT / 100', 'buyerValue = escrows[_tradeHash].summ - arbitratorValue', 'buyerReceivedMoney = escrows[_tradeHash].buyer.call.value(buyerValue)()', 'arbitratorReceivedMoney = arbitrator.call.value(arbitratorValue)()']
[cfg_Reentrancy in] contract: SysEscrow . function: cancelEscrow(bytes16,address,address,uint256) | Reentrancy\test2219.sol#81-108
	To analyze：SysEscrow.approveEscrow(bytes16,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SysEscrow.releaseEscrow(bytes16,address,address,uint256)
		contract: SysEscrow | function: releaseEscrow(bytes16,address,address,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_tradeHash = keccak256()(_tradeID,_seller,_buyer,_value)', 'require(bool)(escrows[_tradeHash].exists)', 'require(bool)(escrows[_tradeHash].buyerApprovedTheTransaction)', 'arbitratorValue = escrows[_tradeHash].summ * ARBITRATOR_PERCENT / 100', 'buyerValue = escrows[_tradeHash].summ - arbitratorValue', 'sellerReceivedMoney = escrows[_tradeHash].seller.call.value(buyerValue)()']
		contract: SysEscrow | function: releaseEscrow(bytes16,address,address,uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_tradeHash = keccak256()(_tradeID,_seller,_buyer,_value)', 'require(bool)(escrows[_tradeHash].exists)', 'require(bool)(escrows[_tradeHash].buyerApprovedTheTransaction)', 'arbitratorValue = escrows[_tradeHash].summ * ARBITRATOR_PERCENT / 100', 'buyerValue = escrows[_tradeHash].summ - arbitratorValue', 'sellerReceivedMoney = escrows[_tradeHash].seller.call.value(buyerValue)()', 'arbitratorReceivedMoney = arbitrator.call.value(arbitratorValue)()']
[cfg_Reentrancy in] contract: SysEscrow . function: releaseEscrow(bytes16,address,address,uint256) | Reentrancy\test2219.sol#126-154
	To analyze：SysEscrow.isExistsEscrow(bytes16,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2219.sol
Start Contract ERC721
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min(int256,int256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bid(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._currentPrice(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCurrentPrice(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsBase
Start Contract EthernautsAccessControl
	To analyze：EthernautsAccessControl.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsStorage
	To analyze：EthernautsStorage.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.EthernautsStorage()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.grantAccess(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.removeAccess(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.createAsset(uint256,address,uint256,uint16,uint8,uint8,uint8,uint8[10],uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.editAsset(uint256,uint256,uint256,uint16,uint8,uint8,uint8,uint8[10],uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.updateStats(uint256,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.updateState(uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.setAssetCooldown(uint256,uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.getStats(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.hasAllAttrs(uint256,bytes2)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.hasAnyAttrs(uint256,bytes2)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.isCategory(uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.isState(uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.approvedFor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsStorage.getTokenList(address,uint8,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsOwnership
	To analyze：EthernautsOwnership.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership._transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.createNewAsset(uint256,address,uint256,uint16,uint8,uint8,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsOwnership.isExploring(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsLogic
	To analyze：EthernautsLogic.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic._transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.createNewAsset(uint256,address,uint256,uint16,uint8,uint8,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.isExploring(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.EthernautsLogic()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.setEthernautsStorageContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.withdrawBalances(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsLogic.getBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract EthernautsMarket
	To analyze：EthernautsMarket._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._bid(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._currentPrice(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._computeCurrentPrice(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setCTO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setOracle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket._transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.createNewAsset(uint256,address,uint256,uint16,uint8,uint8,uint8[10])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.isExploring(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.EthernautsLogic()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setEthernautsStorageContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.withdrawBalances(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.EthernautsMarket(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.bid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.createAuctionWhenPaused(address,address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.createSaleAuction(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setOwnerCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setStepLimits(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthernautsMarket.setPercentages(uint8,uint8,uint8,uint8,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2333.sol
Start Contract SortitionSumTreeFactory
	To analyze：SortitionSumTreeFactory.createTree(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.set(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.queryLeafs(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.draw(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.stakeOf(SortitionSumTreeFactory.SortitionSumTrees,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.updateParents(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract RNG
	To analyze：RNG.requestRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RNG.getUncorrelatedRN(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Arbitrator
	To analyze：Arbitrator.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IArbitrable
Start Contract Arbitrable
	To analyze：Arbitrable.constructor(Arbitrator,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrable.rule(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract TokenController
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract KlerosLiquid
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.constructor(address,MiniMeToken,RNG,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeGovernorProposal(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeGovernor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changePinakion(MiniMeToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeRNGenerator(RNG)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeMinStakingTime(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeMaxDrawingTime(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createSubcourt(uint96,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtMinStake(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtAlpha(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorFee(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorsForJump(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtTimesPerPeriod(uint96,uint256[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPhase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.setStake(uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeDelayedSetStakes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.drawJurors(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.castCommit(uint256,uint256[],bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.castVote(uint256,uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.computeTokenAndETHRewards(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.execute(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.arbitrationCost(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealCost(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.disputeStatus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.currentRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid._setStake(address,uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.extraDataToSubcourtIDAndMinJurors(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.accountAndSubcourtIDToStakePathID(address,uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakePathIDToAccountAndSubcourtID(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getSubcourt(uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVote(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVoteCounter(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getDispute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getJuror(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakeOf(address,uint96)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2344.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PrivateInvestment
	To analyze：PrivateInvestment.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.PrivateInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.loggedTransfer(uint256,bytes32,address,address)
		contract: PrivateInvestment | function: loggedTransfer(uint256,bytes32,address,address) | accessPermision: True | publicCaller: True | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'TransferHappened(amount,logMsg,target,currentOwner)', '! target.call.value(amount)()']
[cfg_Reentrancy in] contract: PrivateInvestment . function: loggedTransfer(uint256,bytes32,address,address) | Reentrancy\test2454.sol#51-56
	To analyze：PrivateInvestment.invest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.divest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.calculateDividend()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.getInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.payDividend()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.distributeDividends()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.doTransfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.setMinInvestment(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateInvestment.destroy()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2454.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMathLib
	To analyze：SafeMathLib.times(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMathLib.minus(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMathLib.plus(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Haltable
	To analyze：Haltable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Haltable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Haltable.halt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Haltable.unhalt()
		cfg分析安全，所以开始ICFG的分析
Start Contract PricingStrategy
	To analyze：PricingStrategy.isPricingStrategy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PricingStrategy.isSane(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PricingStrategy.isPresalePurchase(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract FinalizeAgent
	To analyze：FinalizeAgent.isFinalizeAgent()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract ERC20
Start Contract FractionalERC20
Start Contract Crowdsale
	To analyze：Crowdsale.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.halt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.unhalt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.Crowdsale(address,PricingStrategy,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.investInternal(address,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.preallocate(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.investWithSignedAddress(address,uint128,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.investWithCustomerId(address,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.invest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buyWithSignedAddress(uint128,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buyWithCustomerId(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setFinalizeAgent(FinalizeAgent)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setRequireCustomerId(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setRequireSignedAddress(bool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setEarlyParicipantWhitelist(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setEndsAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setPricingStrategy(PricingStrategy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setMultisig(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.loadRefund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.refund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isMinimumGoalReached()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isFinalizerSane()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isPricingSane()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.getState()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setOwnerTestValue(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.isCrowdsale()
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.isToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PreICOProxyBuyer
	To analyze：PreICOProxyBuyer.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.halt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.unhalt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.PreICOProxyBuyer(address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.invest(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.buyWithCustomerId(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.buyForEverybody()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getClaimAmount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getClaimLeft(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.claimAll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.claim(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.refund()
		contract: PreICOProxyBuyer | function: refund() | accessPermision: False | 锁: True | 钱提前更新：True
			path: ['entryPoint', 'getState() != State.Refunding', 'None', 'investor = msg.sender', 'balances[investor] == 0', 'None', 'amount = balances[investor]', 'delete balances[investor]', '! (investor.call.value(amount)())']
[cfg_Reentrancy in] contract: PreICOProxyBuyer . function: refund() | Reentrancy\test2488.sol#1172-1183
	To analyze：PreICOProxyBuyer.setCrowdsale(Crowdsale)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.forceRefund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.loadRefund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.getState()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.isPresale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreICOProxyBuyer.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2488.sol
Start Contract PreSaleFund
	To analyze：PreSaleFund.loggedTransfer(uint256,bytes32,address,address)
		contract: PreSaleFund | function: loggedTransfer(uint256,bytes32,address,address) | accessPermision: True | publicCaller: True | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.sender != address(this)', 'None', 'target.call.value(amount)()']
[cfg_Reentrancy in] contract: PreSaleFund . function: loggedTransfer(uint256,bytes32,address,address) | Reentrancy\test2502.sol#12-20
	To analyze：PreSaleFund.Invest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.Divest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.GetInvestedAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.withdraw()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2502.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract InvestorsStorage
	To analyze：InvestorsStorage.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.updateInfo(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.updateCheckpoint(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.addReferrer(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.getInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.d(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.c(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：InvestorsStorage.r(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartPyramid
	To analyze：SmartPyramid.bytesToAddress(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.addReferrer(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.getInfo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.getTop()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.invest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.toTheTop()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.payDay()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartPyramid.nextWave()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2597.sol
Start Contract PreSaleFund
	To analyze：PreSaleFund.loggedTransfer(uint256,bytes32,address,address)
		contract: PreSaleFund | function: loggedTransfer(uint256,bytes32,address,address) | accessPermision: True | publicCaller: True | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'msg.sender != address(this)', 'None', 'target.call.value(amount)()']
[cfg_Reentrancy in] contract: PreSaleFund . function: loggedTransfer(uint256,bytes32,address,address) | Reentrancy\test2598.sol#12-20
	To analyze：PreSaleFund.Invest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.Divest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.GetInvestedAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PreSaleFund.withdraw()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2598.sol
Start Contract Owned
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenRecipient
Start Contract TokenERC20
	To analyze：TokenERC20.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinToken
	To analyze：MifflinToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: MifflinToken . function: contribution(uint256) | Reentrancy\test2601.sol#216-233
	To analyze：MifflinToken.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BeetBuck
	To analyze：BeetBuck.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: BeetBuck . function: contribution(uint256) | Reentrancy\test2601.sol#216-233
	To analyze：BeetBuck.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.BeetBuck(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NapNickel
	To analyze：NapNickel.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NapNickel . function: contribution(uint256) | Reentrancy\test2601.sol#216-233
	To analyze：NapNickel.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.NapNickel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isLeapYear(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.leapYearsBefore(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDaysInMonth(uint8,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestampParts(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestamp(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getYear(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMonth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDay(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getHour(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMinute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getSecond(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getWeekday(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract QuabityQuarter
	To analyze：QuabityQuarter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: QuabityQuarter . function: contribution(uint256) | Reentrancy\test2601.sol#216-233
	To analyze：QuabityQuarter.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.QuabityQuarter(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract KelevinKoin
	To analyze：KelevinKoin.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: KelevinKoin . function: contribution(uint256) | Reentrancy\test2601.sol#216-233
	To analyze：KelevinKoin.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.KelevinKoin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NnexNote
	To analyze：NnexNote.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NnexNote . function: contribution(uint256) | Reentrancy\test2601.sol#216-233
	To analyze：NnexNote.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.NnexNote(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract DundieDollar
	To analyze：DundieDollar.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: DundieDollar . function: contribution(uint256) | Reentrancy\test2601.sol#216-233
	To analyze：DundieDollar.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.DundieDollar(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addAward(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardBalanceOf(address,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardName(uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinMarket
	To analyze：MifflinMarket.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.MifflinMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setToken(uint8,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeToken(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setActive(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getRewardToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenById(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensByAddress(uint256,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensById(uint256,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.highContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.lowContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2601.sol
Start Contract Etheropt
	To analyze：Etheropt.Etheropt(uint256,string,uint256,uint256,bytes32,address,int256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getAccountID(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getAccount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.addFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.withdrawFunds(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getFunds(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getFundsAndAvailable(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.marketMaker(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getMarketMakers()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getMarketMakerFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getOptionChain()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getMarket(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.expire(uint256,uint8,bytes32,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getMoneyness(int256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.orderMatchTest(uint256,uint256,int256,uint256,uint256,address,address,uint256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.orderMatch(uint256,uint256,int256,uint256,uint256,address,uint8,bytes32,bytes32,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.getMaxLossAfterTrade(address,uint256,int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.moneySumAtSettlement(address,uint256,int256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheropt.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2681.sol
Start Contract ERC20Basic
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BasicToken
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract StandardToken
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecTokenSmartContract
	To analyze：ElecTokenSmartContract.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.ElecTokenSmartContract(uint256,uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecTokenSmartContract.emergencyERC20Drain(ERC20,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecApprover
	To analyze：ElecApprover.ElecApprover(ElecWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.contributedCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.contributedInternalCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecApprover.saleStarted()
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecWhitelist
	To analyze：ElecWhitelist.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.ElecWhitelist()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.listAddress(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.listAddresses(address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.setUsersCap(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.getCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecWhitelist.destroy()
		cfg分析安全，所以开始ICFG的分析
Start Contract ElecSaleSmartContract
	To analyze：ElecSaleSmartContract.ElecApprover(ElecWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.contributedCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.contributedInternalCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.saleStarted()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.ElecSaleSmartContract(address,address,ElecWhitelist,uint256,uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.setHaltSale(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.proxyBuy(bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.sendETHToMultiSig(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.finalizeSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ElecSaleSmartContract.emergencyDrain(ERC20)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test269.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract TokenController
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Contribution
	To analyze：Contribution.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.Contribution(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.initialize(address,address,address,address,address,address,address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.exchangeRate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.tokensToGenerate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.allowTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.doBuy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollectByInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockNumber()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockTimestamp()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.pauseContribution(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Exchanger
	To analyze：Exchanger.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.Exchanger(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.collect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.getBlockNumber()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.getBlockTimestamp()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Exchanger.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2696.sol
Start Contract BdpContracts
	To analyze：BdpContracts.getBdpEntryPoint(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpController(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpControllerHelper(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpDataStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpImageStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpOwnershipStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpPriceStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpBaseData
Start Contract BdpBase
	To analyze：BdpBase.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.kill()
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpDataStorage
	To analyze：BdpDataStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getLastRegionId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getNextRegionId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.deleteRegionData(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionCoordinates(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionCoordinates(uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionCurrentImageId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionCurrentImageId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionNextImageId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionNextImageId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionUrl(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionUrl(uint256,uint8[128])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionCurrentPixelPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionCurrentPixelPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionBlockUpdatedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionBlockUpdatedAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionUpdatedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionUpdatedAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionPurchasedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionPurchasedAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionUpdatedAtPurchasedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionPurchasePixelPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionPurchasedPixelPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.BdpDataStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpImageStorage
	To analyze：BdpImageStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getLastImageId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getNextImageId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.createImage(address,uint256,uint16,uint16,uint16,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.imageExists(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.deleteImage(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageOwner(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageRegionId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageRegionId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageCurrentRegionId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageCurrentRegionId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageData(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageData(uint256,uint16,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageDataLength(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageDataLength(uint256,uint16,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImagePartsCount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImagePartsCount(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageWidth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageWidth(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageHeight(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageHeight(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageDescriptor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageDescriptor(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageBlurredAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageBlurredAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.imageUploadComplete(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.BdpImageStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpOwnershipStorage
	To analyze：BdpOwnershipStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenOwner(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenApproval(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenApproval(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedArea(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setOwnedArea(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.incrementOwnedArea(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.decrementOwnedArea(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedTokensLength(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setOwnedToken(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.pushOwnedToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.decrementOwnedTokensLength(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedTokensIndex(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setOwnedTokensIndex(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenIdsLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenIdByIndex(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenIdByIndex(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.pushTokenId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.decrementTokenIdsLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenIdsIndex(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenIdsIndex(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.BdpOwnershipStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpPriceStorage
	To analyze：BdpPriceStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getPricePointsLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getPricePoint(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setPricePoints(uint64[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.appendPricePoints(uint64[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getForwardPurchaseFeesTo()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setForwardPurchaseFeesTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getForwardUpdateFeesTo()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setForwardUpdateFeesTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.BdpPriceStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpCalculator
	To analyze：BdpCalculator.calculateArea(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.countPurchasedPixels(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateCurrentMarketPixelPrice(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateMarketPixelPrice(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateAveragePixelPrice(address[16],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateRegionInitialSalePixelPrice(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateRegionSalePixelPrice(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateSetupAllowedUntil(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpImage
	To analyze：BdpImage.checkImageInput(address[16],uint256,uint256,uint256[],bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImage.setNextImagePart(address[16],uint256,uint16,uint16,uint16,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImage.setImageOwner(address[16],uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImage.setImageData(address[16],uint256,uint16,uint256[])
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpOwnership
	To analyze：BdpOwnership.ownerOf(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.balanceOf(address[16],address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.approve(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.clearApproval(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.clearApprovalAndTransfer(address[16],address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.addToken(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.removeToken(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.removeFromOwnedToken(BdpOwnershipStorage,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.removeFromTokenIds(BdpOwnershipStorage,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.mint(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.burn(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpCrud
	To analyze：BdpCrud.createRegion(address[16],address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.deleteRegion(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.setupRegion(address[16],uint256,uint256,uint256[],bool,uint8[128])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.updateRegion(address[16],uint256,uint256,uint256[],bool,bool,uint8[128],bool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.updateRegionPixelPrice(address[16],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._processUpdateFee(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._updateRegionImage(address[16],BdpDataStorage,uint256,uint256,uint256[],bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._updateRegionUrl(BdpDataStorage,uint256,uint8[128],bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._updateRegionOwner(address[16],uint256,address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2753.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test276.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Interface
Start Contract Etx
Start Contract Ethex
	To analyze：Ethex.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.Ethex(address,address,uint256,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.changeAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.changeETXAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.changeLastFreeBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.changeFeeAccount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.changeMakeFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.changeTakeFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.feeFromTotalCostForAccount(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.feeFromTotalCost(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.calculateFeeForAccount(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.calculateFee(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.makeSellOrder(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.makeBuyOrder(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.cancelAllSellOrders(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.cancelAllBuyOrders(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.takeBuyOrder(address,uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ethex.takeSellOrder(address,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2794.sol
Start Contract BTCRelay
Start Contract PoissonData
Start Contract Escrow
Start Contract EthereumLottery
	To analyze：EthereumLottery.EthereumLottery(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.needsInitialization()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.initLottery(uint256,uint256,uint256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.buyTickets(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.needsFinalization()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.finalizeLottery(uint256)
		contract: EthereumLottery | function: finalizeLottery(uint256) | accessPermision: False | 锁: True | 钱提前更新：True
			path: ['entryPoint', 'require(bool)(needsFinalization())', 'lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock', 'winningTicket = lotteries[id].nearestKnownBlockHash % int256(lotteries[id].numTickets)', 'winner = lotteries[id].tickets[uint256(winningTicket)]', 'lotteries[id].winningTicket = winningTicket', 'lotteries[id].winner = winner', 'lotteries[id].finalizationBlock = block.number', 'lotteries[id].finalizer = tx.origin', 'winner != 0', 'None', '_ = admin.call.gas(GAS_LIMIT).value(this.balance)()']
			path: ['entryPoint', 'require(bool)(needsFinalization())', 'lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock', 'winningTicket = lotteries[id].nearestKnownBlockHash % int256(lotteries[id].numTickets)', 'winner = lotteries[id].tickets[uint256(winningTicket)]', 'lotteries[id].winningTicket = winningTicket', 'lotteries[id].winner = winner', 'lotteries[id].finalizationBlock = block.number', 'lotteries[id].finalizer = tx.origin', 'winner != 0', 'value = lotteries[id].jackpot', 'successful = winner.call.gas(GAS_LIMIT).value(value)()', '! successful', 'None', 'None', '_ = admin.call.gas(GAS_LIMIT).value(this.balance)()']
			path: ['entryPoint', 'require(bool)(needsFinalization())', 'lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock', 'winningTicket = lotteries[id].nearestKnownBlockHash % int256(lotteries[id].numTickets)', 'winner = lotteries[id].tickets[uint256(winningTicket)]', 'lotteries[id].winningTicket = winningTicket', 'lotteries[id].winner = winner', 'lotteries[id].finalizationBlock = block.number', 'lotteries[id].finalizer = tx.origin', 'winner != 0', 'value = lotteries[id].jackpot', 'successful = winner.call.gas(GAS_LIMIT).value(value)()', '! successful', 'Escrow(escrow).deposit.value(value)(winner)', 'None', 'None', '_ = admin.call.gas(GAS_LIMIT).value(this.balance)()']
[cfg_Reentrancy in] contract: EthereumLottery . function: finalizeLottery(uint256) | Reentrancy\test2932.sol#158-184
	To analyze：EthereumLottery.walkTowardsBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getMessageLength(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.setMessage(int256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getLotteryDetailsA(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getLotteryDetailsB(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getTicketDetails(int256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getTicketOwner(int256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.getRecentActivity()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.setAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.proposeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EthereumLottery.destruct()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test2932.sol
Start Contract Pie
	To analyze：Pie.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Get()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3058.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.assert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Token
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ValueToken
	To analyze：ValueToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.createValue(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueToken.destroyValue(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ValueTrader
	To analyze：ValueTrader.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.createValue(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.destroyValue(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.toggleDrain()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.toggleBurn()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.die()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.validateToken(address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.configureTokenDividend(address,bool,address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.callDividend(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.invalidateToken(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.changeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.changeFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.changeEtherContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.ValueTrader()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.valueWithFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.currentPrice(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.currentLiquidity(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.valueToToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.tokenToValue(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.sellToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.buyToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.sellEther()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.buyEther(uint256)
		contract: ValueTrader | function: buyEther(uint256) | accessPermision: True | publicCaller: True | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'assert(valueToToken(etherContract,balances[msg.sender]) >= amount)', 'assert(destroyValue(msg.sender,tokenToValue(etherContract,amount)))', 'assert(msg.sender.call.value(amount)())']
[cfg_Reentrancy in] contract: ValueTrader . function: buyEther(uint256) | Reentrancy\test3061.sol#300-305
	To analyze：ValueTrader.quickTrade(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ValueTrader.verifiedTransferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ShopKeeper
	To analyze：ShopKeeper.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.ShopKeeper(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.giveAwayOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.splitProfits()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.toggleDrain()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.toggleBurn()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.die()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.validateToken(address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.configureTokenDividend(address,bool,address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.callDividend(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.invalidateToken(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.changeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.changeShop(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.changeFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShopKeeper.changeEtherContract(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ProfitContainerAdapter
	To analyze：ProfitContainerAdapter.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.changeShop(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.changeKeeper(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.changeContainer(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.ProfitContainerAdapter(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.takeEtherProfits()
		contract: ProfitContainerAdapter | function: takeEtherProfits() | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'ShopKeeper(shopKeeperLocation).splitProfits()', 'shop = ValueTrader(shopLocation)', 'shop.buyEther(shop.balanceOf(this))', 'assert(profitContainerLocation.call.value(this.balance)())']
[cfg_Reentrancy in] contract: ProfitContainerAdapter . function: takeEtherProfits() | Reentrancy\test3061.sol#466-471
	To analyze：ProfitContainerAdapter.takeTokenProfits(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.giveAwayHoldership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ProfitContainerAdapter.giveAwayOwnership(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3061.sol
Start Contract IStdToken
Start Contract EtheramaCommon
	To analyze：EtheramaCommon.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isManager(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaGasPriceLimit
	To analyze：EtheramaGasPriceLimit.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaCore
	To analyze：EtheramaCore.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.changeControllerContract(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setBigPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setQuickPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setPromoMinPurchaseEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMinRefEthPurchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setTotalIncomeFeePercent(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setRewardPercentages(uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutQuickBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutBigBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBonusPerShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRewardPayouts(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackBuy(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackSell(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackTotalVolume(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBuyCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getSellCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeEth(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeToken(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserEthVolumeSaldo(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserQuickPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserBigPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTokenLocalBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.subUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserReward(address,address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalReward(address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserReward(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserTotalReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserShareBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawUserReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getRewardAndPrepareWithdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawRemainingEthAfterAll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.calcPercent(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convertRealTo256(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convert256ToReal(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaData
	To analyze：EtheramaData.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.init()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isInited()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCoreAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setNewControllerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getAdministratorCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCommonInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.resetTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setTotalSupply(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setRealTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTokenLocalBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getActualUserTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRewardPayouts(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserReward(address,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTotalPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserBigPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserQuickPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherama
	To analyze：Etherama.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.transferOwnershipRequest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.activate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.finish()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.buy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sell(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.withdrawTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.prepareForMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMaxGasPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getExpirationTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTimeTillExpiration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserAdministrator()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDataContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.requestControllerContractMigration(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.approveControllerContractMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateToNewNewControllerContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenInitialPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDevRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getShareRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRefBonusPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedTokenBlock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMinRefEthPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentTokenPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalEthBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserLocalTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserLocalTokenBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getEthDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserReward(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenSellPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenBuyPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateBuyOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateSellOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserMaxPurchase(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserMaxPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserTotalPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.purchaseTokens(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.setTotalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.checkAndSendPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.distributeFee(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addProfitPerShare(uint256,address)
		cfg分析安全，所以开始ICFG的分析
		contract: Etherama | function: addProfitPerShare(uint256,address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'refBonus = calcRefBonus(totalFeeEth)', 'totalShareReward = calcTotalShareRewardFee(totalFeeEth)', 'refAddress != address(0x0)', '_core.addUserRefBalance.value(refBonus)(refAddress)', 'None', 'getTotalTokenSold() == 0', '_core.addBonusPerShare.value(totalShareReward)()', [['taint', 'addBonusPerShare()']]]
[Icfg_Reentrancy in] contract: Etherama . function: addProfitPerShare(uint256,address) | Reentrancy\test3136.sol#1355-1370
	To analyze：Etherama.addDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.subUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.updateTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.ethToTokens(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.tokensToEth(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalFee(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calc1RealTokenRateFromRealTokens(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRealPriceSpeed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalShareRewardFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcRefBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract RealMath
	To analyze：RealMath.getMinInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.getMaxInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt256ValidIn64(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt256ValidIn64(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt64ValidIn64(uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt128ValidIn64(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.toReal(int64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fromReal(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.abs(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpartSigned(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.mul(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.div(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fraction(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.hibit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.findbit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.rescale(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.lnLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ln(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.exp(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.pow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3136.sol
Start Contract Ownable
	To analyze：Ownable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20SafeTransfer
	To analyze：ERC20SafeTransfer.safeTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20SafeTransfer.safeTransferFrom(address,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20SafeTransfer.safeApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20SafeTransfer.fetchReturnData()
		cfg分析安全，所以开始ICFG的分析
Start Contract Withdrawable
	To analyze：Withdrawable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Withdrawable.withdrawETH(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract TokenTransferProxy
	To analyze：TokenTransferProxy.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.addAuthorizedAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.removeAuthorizedAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.transferFrom(address,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenTransferProxy.getAuthorizedAddresses()
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.paused()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Utils
	To analyze：Utils.precision()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_qty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_rate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.eth_decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.max_uint()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.getDecimals(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.tokenAllowanceAndBalanceSet(address,address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcDstQty(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcSrcQty(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcDestAmount(ERC20,ERC20,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcSrcAmount(ERC20,ERC20,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.calcRateFromQty(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ErrorReporter
	To analyze：ErrorReporter.revertTx(string)
		cfg分析安全，所以开始ICFG的分析
Start Contract Affiliate
	To analyze：Affiliate.init(address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Affiliate.payout()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Affiliate.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Affiliate.getTotalFeePercentage()
		cfg分析安全，所以开始ICFG的分析
Start Contract AffiliateRegistry
	To analyze：AffiliateRegistry.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.constructor(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.registerAffiliate(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.overrideRegisterAffiliate(address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.deleteAffiliate(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.createClone()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.isValidAffiliate(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AffiliateRegistry.updateCompanyInfo(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TotleControl
	To analyze：TotleControl.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.addTotle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotleControl.removeTotle(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SelectorProvider
Start Contract ExchangeHandler
	To analyze：ExchangeHandler.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.paused()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.withdrawETH(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.addTotle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.removeTotle(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.getAmountToGive(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.staticExchangeChecks(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.performBuyOrder(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExchangeHandler.performSellOrder(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TotlePrimary
	To analyze：TotlePrimary.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.paused()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.withdrawETH(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.constructor(address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.updateDefaultFeeAccount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.addHandlerToWhitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.removeHandlerFromWhitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.performRebalance(TotlePrimary.Trade[],address,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.staticChecks(TotlePrimary.Trade[],TotlePrimary.TradeFlag[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.initialiseTradeFlags(TotlePrimary.Trade[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.transferTokensToUser(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.performTrade(TotlePrimary.Trade,TotlePrimary.TradeFlag,TotlePrimary.CurrentAmounts)
		contract: TotlePrimary | function: performTrade(TotlePrimary.Trade,TotlePrimary.TradeFlag,TotlePrimary.CurrentAmounts) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'None', 'None', 'j < trade.orders.length', 'amounts.amountLeftToSpendOnTrade * 10000 < (amounts.amountSpentOnTrade + amounts.amountLeftToSpendOnTrade)', 'None', 'trade.isSell', '(amounts.amountReceivedFromTrade) >= trade.tokenAmount', 'None', 'None', 'tradeFlag.ignoreOrder[j] || amounts.amountLeftToSpendOnTrade == 0', 'None', 'amountSpentOnOrder = 0', 'amountReceivedFromOrder = 0', 'thisOrder = trade.orders[j]', 'thisHandler = ExchangeHandler(thisOrder.exchangeHandler)', 'amountToGiveForOrder = Utils.min(thisHandler.getAmountToGive(thisOrder.genericPayload),amounts.amountLeftToSpendOnTrade)', 'amountToGiveForOrder == 0', 'None', '! thisHandler.staticExchangeChecks(thisOrder.genericPayload)', 'None', 'trade.isSell', '(amountSpentOnOrder,amountReceivedFromOrder) = thisHandler.performBuyOrder.value(amountToGiveForOrder)(thisOrder.genericPayload,amountToGiveForOrder)']
			path: ['entryPoint', 'None', 'None', 'j < trade.orders.length', 'amounts.amountLeftToSpendOnTrade * 10000 < (amounts.amountSpentOnTrade + amounts.amountLeftToSpendOnTrade)', 'None', 'trade.isSell', '(amounts.amountSpentOnTrade) >= trade.tokenAmount', 'None', 'None', 'tradeFlag.ignoreOrder[j] || amounts.amountLeftToSpendOnTrade == 0', 'None', 'amountSpentOnOrder = 0', 'amountReceivedFromOrder = 0', 'thisOrder = trade.orders[j]', 'thisHandler = ExchangeHandler(thisOrder.exchangeHandler)', 'amountToGiveForOrder = Utils.min(thisHandler.getAmountToGive(thisOrder.genericPayload),amounts.amountLeftToSpendOnTrade)', 'amountToGiveForOrder == 0', 'None', '! thisHandler.staticExchangeChecks(thisOrder.genericPayload)', 'None', 'trade.isSell', '(amountSpentOnOrder,amountReceivedFromOrder) = thisHandler.performBuyOrder.value(amountToGiveForOrder)(thisOrder.genericPayload,amountToGiveForOrder)']
[cfg_Reentrancy in] contract: TotlePrimary . function: performTrade(TotlePrimary.Trade,TotlePrimary.TradeFlag,TotlePrimary.CurrentAmounts) | Reentrancy\test3157.sol#1235-1327
	To analyze：TotlePrimary.checkIfTradeAmountsAcceptable(TotlePrimary.Trade,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.transferTokens(TotlePrimary.Trade[],TotlePrimary.TradeFlag[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.calculateMaxEtherSpend(TotlePrimary.Trade,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.calculateFee(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.removeFee(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TotlePrimary.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3157.sol
Start Contract Pie
	To analyze：Pie.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Get()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pie.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3206.sol
Start Contract Utils
	To analyze：Utils.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IOwned
	To analyze：IOwned.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract Owned
	To analyze：Owned.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
Start Contract Managed
	To analyze：Managed.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenHolder
	To analyze：ITokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenHolder
	To analyze：TokenHolder.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartTokenController
	To analyze：SmartTokenController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC20Token
	To analyze：IERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract IEtherToken
	To analyze：IEtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISmartToken
	To analyze：ISmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorFormula
Start Contract ITokenChanger
Start Contract BancorChanger
	To analyze：BancorChanger.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.BancorChanger(ISmartToken,IBancorFormula,uint32,IERC20Token,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.reserveTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableToken(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setFormula(IBancorFormula)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setQuickBuyPath(IERC20Token[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.clearQuickBuyPath()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyPathLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.hasQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableChanging(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setChangeFee(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getChangeFeeAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.addReserve(IERC20Token,uint32,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.updateReserve(IERC20Token,uint32,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableReservePurchases(IERC20Token,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReserveBalance(IERC20Token)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReturn(IERC20Token,IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getPurchaseReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.change(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.buy(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.sell(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickChange(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickBuy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.ensureAllowance(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.claimTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3230.sol
Start Contract ERC20
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Distribution
	To analyze：Distribution.Distribution(address,ERC20,bytes32[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.handleTokensReceived()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution._numTokensForContributor(uint256,Distribution.State)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.doDistribution(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.doDistributionRange(uint256,address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.numTokensForContributor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.temporaryEscapeHatch(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Distribution.temporaryKill(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3235.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test329.sol
Start Contract ERC20
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract YggdrashCrowd
	To analyze：YggdrashCrowd.YggdrashCrowd(address,address,address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.setupToken(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.startContruibute()
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.changeSettings(uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.amountOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.contruibuteData(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.isContruibuteOpen()
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.halt()
		cfg分析安全，所以开始ICFG的分析
	To analyze：YggdrashCrowd.finalizeContruibute()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3316.sol
Start Contract JIincInterfaceForForwarder
Start Contract JIincForwarder
	To analyze：JIincForwarder.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.fallback()
		contract: JIincForwarder | function: fallback() | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'currentCorpBank_.deposit.value(address(this).balance)(address(currentCorpBank_))']
[cfg_Reentrancy in] contract: JIincForwarder . function: fallback() | Reentrancy\test3369.sol#76-83
	To analyze：JIincForwarder.deposit()
		contract: JIincForwarder | function: deposit() | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool,string)(msg.value > 0,Forwarder Deposit failed - zero deposits not allowed)', 'require(bool,string)(needsBank_ == false,Forwarder Deposit failed - no registered bank)', 'currentCorpBank_.deposit.value(msg.value)(msg.sender) == true']
[cfg_Reentrancy in] contract: JIincForwarder . function: deposit() | Reentrancy\test3369.sol#85-96
	To analyze：JIincForwarder.status()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.startMigration(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.cancelMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.finishMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：JIincForwarder.setup(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3369.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy\test3377.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3377.sol
Start Contract REPOPAccessControl
	To analyze：REPOPAccessControl.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PullPayment
	To analyze：PullPayment.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PullPayment.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MetadataContract
	To analyze：MetadataContract.getMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._memcpy(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._toString(bytes32[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.getMetadataUrl(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.uintToBytes(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPERC721
	To analyze：REPOPERC721.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CarefulTransfer
	To analyze：CarefulTransfer.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MoneyManager
	To analyze：MoneyManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract RoundMoneyNicely
	To analyze：RoundMoneyNicely.roundMoneyDownNicely(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RoundMoneyNicely.roundMoneyUpToWholeFinney(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AuctionManager
	To analyze：AuctionManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.AuctionManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllActiveAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.createAuction(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.bid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.endAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.requiredBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuctionStartBid()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setAuctionStartBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MarketManager
	To analyze：MarketManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.MarketManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllActiveSales()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllSalesByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.purchasePop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellPop(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.cancelSellPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.changeSellPOPPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract CloningInterface
Start Contract GenesMarket
	To analyze：GenesMarket.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.GenesMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.startSellingGenes(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.stopSellingGenes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.useBottle(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.purchaseGenes(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSaleBySeller(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getAmountOfGene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getMyGenes()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.changeSellGenesPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPCore
	To analyze：REPOPCore.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.REPOPCore()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setAuctionManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getAuctionManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMarketManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getMarketManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGeneScienceAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGenesMarketAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGenesMarketAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellPop(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellGenes(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnerInAnyPlatformById(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopName(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.removeCooldown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._ownerOfPopInAnyPlatform(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnershipForCloning(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.changeRefresherFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithTwoPops(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithPopAndBottle(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3393.sol
Start Contract Escrow
	To analyze：Escrow.deposit(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Escrow.claim()
		contract: Escrow | function: claim() | accessPermision: False | 锁: False | 钱提前更新：True
			path: ['entryPoint', 'balance = balances[msg.sender]', 'require(bool)(balance > 0)', 'balances[msg.sender] = 0', 'claimed = msg.sender.call.value(balance)()']
[cfg_Reentrancy in] contract: Escrow . function: claim() | Reentrancy\test3454.sol#11-19
./Reentrancy\test3454.sol
Start Contract Utils
	To analyze：Utils.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IOwned
	To analyze：IOwned.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract Owned
	To analyze：Owned.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
Start Contract Managed
	To analyze：Managed.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenHolder
	To analyze：ITokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenHolder
	To analyze：TokenHolder.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartTokenController
	To analyze：SmartTokenController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC20Token
	To analyze：IERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract IEtherToken
	To analyze：IEtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISmartToken
	To analyze：ISmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorFormula
Start Contract ITokenChanger
Start Contract BancorChanger
	To analyze：BancorChanger.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.BancorChanger(ISmartToken,IBancorFormula,uint32,IERC20Token,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.reserveTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableToken(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setFormula(IBancorFormula)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setQuickBuyPath(IERC20Token[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.clearQuickBuyPath()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyPathLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.hasQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableChanging(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setChangeFee(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getChangeFeeAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.addReserve(IERC20Token,uint32,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.updateReserve(IERC20Token,uint32,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableReservePurchases(IERC20Token,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReserveBalance(IERC20Token)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReturn(IERC20Token,IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getPurchaseReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.change(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.buy(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.sell(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickChange(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickBuy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.ensureAllowance(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.claimTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorLender
	To analyze：BancorLender.isCollateralWithinMargin(uint256,uint256,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.offerPosition(uint256,uint32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.takePosition(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.addCollateral(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.closePosition(uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3492.sol
Start Contract ERC20
Start Contract EnjinBuyer
	To analyze：EnjinBuyer.set_sale_address(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.set_token_address(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.activate_kill_switch(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.withdraw(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.add_to_buy_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.add_to_withdraw_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.claim_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3493.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract DividendDistributorv2
	To analyze：DividendDistributorv2.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.DividendDistributorv2()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.loggedTransfer(uint256,bytes32,address,address)
		contract: DividendDistributorv2 | function: loggedTransfer(uint256,bytes32,address,address) | accessPermision: True | publicCaller: True | 锁: False | 钱提前更新：False
			path: ['entryPoint', '! target.call.value(amount)()']
[cfg_Reentrancy in] contract: DividendDistributorv2 . function: loggedTransfer(uint256,bytes32,address,address) | Reentrancy\test3515.sol#51-56
	To analyze：DividendDistributorv2.invest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.divest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.calculateDividend()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.getInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.payDividend()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.distributeDividends()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.doTransfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.setMinInvestment(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DividendDistributorv2.destroy()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3515.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy\test3516.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3516.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract BettingControllerInterface
Start Contract Betting
	To analyze：Betting.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.Betting()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.changeOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.placeBet(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.setupRace(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.reward()
		contract: Betting | function: reward() | accessPermision: False | 锁: False | 钱提前更新：True
			path: ['entryPoint', 'horses.BTC_delta = int32(coinIndex[horses.BTC].post - coinIndex[horses.BTC].pre) * 100000 / int32(coinIndex[horses.BTC].pre)', 'horses.ETH_delta = int32(coinIndex[horses.ETH].post - coinIndex[horses.ETH].pre) * 100000 / int32(coinIndex[horses.ETH].pre)', 'horses.LTC_delta = int32(coinIndex[horses.LTC].post - coinIndex[horses.LTC].pre) * 100000 / int32(coinIndex[horses.LTC].pre)', 'total_reward = (coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total)', 'total_bettors <= 1', 'house_fee = total_reward.mul(5).div(100)', 'require(bool)(house_fee < address(this).balance)', 'total_reward = total_reward.sub(house_fee)', 'bettingControllerInstance.depositHouseTakeout.value(house_fee)()']
[cfg_Reentrancy in] contract: Betting . function: reward() | Reentrancy\test3532.sol#1263-1324
	To analyze：Betting.calculateReward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.checkReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.claim_reward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.forceVoidRace()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.stringToUintNormalize(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.getCoinIndex(bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.reward_total()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.refund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.recovery()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3532.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract tokenRecipient
Start Contract NamiCrowdSale
	To analyze：NamiCrowdSale.NamiCrowdSale(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferForTeam(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeTransferable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinary(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinaryAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.getPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.burnTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setPresalePhase(NamiCrowdSale.Phase)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setCrowdsaleManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateForInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToBuyer(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BinaryOption
	To analyze：BinaryOption.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.BinaryOption(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeMinEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeOneSession(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeRateWin(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeRateLoss(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeRateFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getChooses()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.resetSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.openSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.invest(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getEtherToBuy(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeSession(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PresaleToken
Start Contract ERC223ReceivingContract
Start Contract NamiExchange
	To analyze：NamiExchange.NamiExchange(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.placeBuyOrder(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.sellNac(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeBidOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallbackExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeAskOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.buyNac(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC23
Start Contract NamiMultiSigWallet
	To analyze：NamiMultiSigWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.NamiMultiSigWallet(address[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.replaceOwner(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.changeRequirement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.submitTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.confirmTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.revokeConfirmation(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.executeTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.isConfirmed(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmationCount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionCount(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getOwners()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmations(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionIds(uint256,uint256,bool,bool)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3566.sol
Start Contract DSSafeAddSub
	To analyze：DSSafeAddSub.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract LuckyDice
	To analyze：LuckyDice.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.LuckyDice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.playerMakeBet(uint256,uint256,bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.getFullProfit(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.getProfit(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.getToJackpot(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.withdraw(bytes32,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.playerWithdrawPendingTransactions()
		contract: LuckyDice | function: playerWithdrawPendingTransactions() | accessPermision: False | 锁: False | 钱提前更新：True
			path: ['entryPoint', 'withdrawAmount = playerPendingWithdrawals[msg.sender]', 'playerPendingWithdrawals[msg.sender] = 0', 'msg.sender.call.value(withdrawAmount)()']
[cfg_Reentrancy in] contract: LuckyDice . function: playerWithdrawPendingTransactions() | Reentrancy\test3610.sol#358-373
	To analyze：LuckyDice.playerGetPendingTxByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerUpdateContractBalance(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetHouseEdge(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetMaxProfit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetJpMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerTransferEther(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerRefundPlayer(bytes32,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerPauseGame(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerPausePayouts(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerSetCasino(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerChangeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyDice.ownerkill()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3610.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
Start Contract strings
	To analyze：strings.memcpy(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.toSlice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.len(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.toSliceB32(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.copy(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.toString(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.len(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.empty(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.compare(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.equals(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.nextRune(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.nextRune(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.ord(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.keccak(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.startsWith(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.beyond(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.endsWith(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.until(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.findPtr(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rfindPtr(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.find(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rfind(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.split(strings.slice,strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.split(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rsplit(strings.slice,strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rsplit(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.count(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.contains(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.concat(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.join(strings.slice,strings.slice[])
		cfg分析安全，所以开始ICFG的分析
Start Contract DSSafeAddSub
	To analyze：DSSafeAddSub.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Etheroll
	To analyze：Etheroll.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.Etheroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.playerRollDice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.playerWithdrawPendingTransactions()
		contract: Etheroll | function: playerWithdrawPendingTransactions() | accessPermision: False | 锁: False | 钱提前更新：True
			path: ['entryPoint', 'withdrawAmount = playerPendingWithdrawals[msg.sender]', 'playerPendingWithdrawals[msg.sender] = 0', 'msg.sender.call.value(withdrawAmount)()']
[cfg_Reentrancy in] contract: Etheroll . function: playerWithdrawPendingTransactions() | Reentrancy\test3616.sol#1567-1582
	To analyze：Etheroll.playerGetPendingTxByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.setMaxProfit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerSetOraclizeSafeGas(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerUpdateContractBalance(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerSetHouseEdge(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerSetMaxProfitAsPercentOfHouse(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerSetMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerTransferEther(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerRefundPlayer(bytes32,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerPauseGame(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerPausePayouts(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerSetTreasury(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerChangeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etheroll.ownerkill()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3616.sol
Start Contract WinEthFree
	To analyze：WinEthFree.isInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.resetInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.calcInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.withdrawInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doInvest(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.WinnerNotReturn(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doBet(address,uint256,WinEthFree.WagerType)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.drawLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.random(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLuckyTickets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.sort(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.quickSort(uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.payTicketsPrize(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextWave()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextBet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeCommission(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doLeverageBet(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLeverageAddress()
		cfg分析安全，所以开始ICFG的分析
Start Contract Leverage
	To analyze：Leverage.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Leverage.fallback()
		contract: Leverage | function: fallback() | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'value = msg.value', 'value > 0', 'address(mainContract).transfer(value)', 'None', 'value = uint256(value / minInvestment) * minInvestment', 'mainContract.doLeverageBet(msg.sender,value)']
[cfg_Reentrancy in] contract: Leverage . function: fallback() | Reentrancy\test3654.sol#457-468
./Reentrancy\test3654.sol
Start Contract ContractReceiverInterface
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract SafeContract
	To analyze：SafeContract.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeContract.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeContract.transferAnyERC20Token(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BasicToken
	To analyze：BasicToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BurnableToken
	To analyze：BurnableToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BurnableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BurnableToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BurnableToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract DetailedERC20
	To analyze：DetailedERC20.DetailedERC20(string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MintableToken
	To analyze：MintableToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.mint(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.finishMinting()
		cfg分析安全，所以开始ICFG的分析
Start Contract FriendsFingersToken
	To analyze：FriendsFingersToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.transferAnyERC20Token(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.mint(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.finishMinting()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.DetailedERC20(string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.FriendsFingersToken(string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract Crowdsale
	To analyze：Crowdsale.Crowdsale(uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.hasEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.createTokenContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
Start Contract CappedCrowdsale
	To analyze：CappedCrowdsale.Crowdsale(uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.hasEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.createTokenContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.CappedCrowdsale(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.hasEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
Start Contract FinalizableCrowdsale
	To analyze：FinalizableCrowdsale.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.Crowdsale(uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.hasEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.createTokenContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FinalizableCrowdsale.finalization()
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract FriendsFingersCrowdsale
	To analyze：FriendsFingersCrowdsale.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.transferAnyERC20Token(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.Crowdsale(uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.hasEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.createTokenContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.finalization()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.CappedCrowdsale(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.hasEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.FriendsFingersCrowdsale(uint256,uint256,uint256,uint256,uint256,uint256,address,FriendsFingersToken,string,uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.claimRefund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.goalReached()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.updateCrowdsaleInfo(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.blockCrowdsale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.setnextRoundId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.setFriendsFingersRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.setFriendsFingersWallet(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.safeWithdrawal()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.setExpiredAndWithdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.createTokenContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersCrowdsale.finalization()
		cfg分析安全，所以开始ICFG的分析
Start Contract FriendsFingersBuilder
	To analyze：FriendsFingersBuilder.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.transferAnyERC20Token(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.FriendsFingersBuilder(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.startCrowdsale(string,string,uint8,uint256,uint256,uint256,uint256,uint256,uint256,address,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.restartCrowdsale(address,uint256,uint256,uint256,uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.closeCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.updateCrowdsaleInfo(address,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.changeEnabledAddressStatus(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.setDefaultFriendsFingersRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.setMainWallet(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.setFriendsFingersRateForCrowdsale(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.setFriendsFingersWalletForCrowdsale(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.pauseCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.unpauseCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.blockCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.safeTokenWithdrawalFromCrowdsale(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.safeWithdrawalFromCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.setExpiredAndWithdraw(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FriendsFingersBuilder.addCrowdsaleToList(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3662.sol
Start Contract BdpContracts
	To analyze：BdpContracts.getBdpEntryPoint(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpController(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpControllerHelper(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpDataStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpImageStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpOwnershipStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpContracts.getBdpPriceStorage(address[16])
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpBaseData
Start Contract BdpBase
	To analyze：BdpBase.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpBase.kill()
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpDataStorage
	To analyze：BdpDataStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getLastRegionId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getNextRegionId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.deleteRegionData(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionCoordinates(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionCoordinates(uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionCurrentImageId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionCurrentImageId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionNextImageId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionNextImageId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionUrl(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionUrl(uint256,uint8[128])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionCurrentPixelPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionCurrentPixelPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionBlockUpdatedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionBlockUpdatedAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionUpdatedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionUpdatedAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionPurchasedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionPurchasedAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionUpdatedAtPurchasedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.getRegionPurchasePixelPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.setRegionPurchasedPixelPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpDataStorage.BdpDataStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpImageStorage
	To analyze：BdpImageStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getLastImageId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getNextImageId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.createImage(address,uint256,uint16,uint16,uint16,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.imageExists(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.deleteImage(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageOwner(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageRegionId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageRegionId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageCurrentRegionId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageCurrentRegionId(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageData(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageData(uint256,uint16,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageDataLength(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageDataLength(uint256,uint16,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImagePartsCount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImagePartsCount(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageWidth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageWidth(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageHeight(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageHeight(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageDescriptor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageDescriptor(uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.getImageBlurredAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.setImageBlurredAt(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.imageUploadComplete(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImageStorage.BdpImageStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpOwnershipStorage
	To analyze：BdpOwnershipStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenOwner(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenApproval(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenApproval(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedArea(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setOwnedArea(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.incrementOwnedArea(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.decrementOwnedArea(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedTokensLength(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setOwnedToken(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.pushOwnedToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.decrementOwnedTokensLength(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getOwnedTokensIndex(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setOwnedTokensIndex(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenIdsLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenIdByIndex(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenIdByIndex(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.pushTokenId(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.decrementTokenIdsLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.getTokenIdsIndex(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.setTokenIdsIndex(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnershipStorage.BdpOwnershipStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpPriceStorage
	To analyze：BdpPriceStorage.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setContracts(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setSetupComplete()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getPricePointsLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getPricePoint(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setPricePoints(uint64[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.appendPricePoints(uint64[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getForwardPurchaseFeesTo()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setForwardPurchaseFeesTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.getForwardUpdateFeesTo()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.setForwardUpdateFeesTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpPriceStorage.BdpPriceStorage(bytes8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpCalculator
	To analyze：BdpCalculator.calculateArea(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.countPurchasedPixels(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateCurrentMarketPixelPrice(address[16])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateMarketPixelPrice(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateAveragePixelPrice(address[16],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateRegionInitialSalePixelPrice(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateRegionSalePixelPrice(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCalculator.calculateSetupAllowedUntil(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpImage
	To analyze：BdpImage.checkImageInput(address[16],uint256,uint256,uint256[],bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImage.setNextImagePart(address[16],uint256,uint16,uint16,uint16,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImage.setImageOwner(address[16],uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpImage.setImageData(address[16],uint256,uint16,uint256[])
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpOwnership
	To analyze：BdpOwnership.ownerOf(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.balanceOf(address[16],address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.approve(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.clearApproval(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.clearApprovalAndTransfer(address[16],address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.addToken(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.removeToken(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.removeFromOwnedToken(BdpOwnershipStorage,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.removeFromTokenIds(BdpOwnershipStorage,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.mint(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpOwnership.burn(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpCrud
	To analyze：BdpCrud.createRegion(address[16],address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.deleteRegion(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.setupRegion(address[16],uint256,uint256,uint256[],bool,uint8[128])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.updateRegion(address[16],uint256,uint256,uint256[],bool,bool,uint8[128],bool,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud.updateRegionPixelPrice(address[16],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._processUpdateFee(address[16],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._updateRegionImage(address[16],BdpDataStorage,uint256,uint256,uint256[],bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._updateRegionUrl(BdpDataStorage,uint256,uint8[128],bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpCrud._updateRegionOwner(address[16],uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BdpTransfer
	To analyze：BdpTransfer.approve(address[16],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BdpTransfer.purchase(address[16],uint256)
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)']
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)']
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId,block.timestamp)']
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId,block.timestamp)']
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedPixelPrice(_regionId,pixelPrice)']
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedPixelPrice(_regionId,pixelPrice)', 'BdpOwnership.clearApprovalAndTransfer(_contracts,BdpOwnership.ownerOf(_contracts,_regionId),msg.sender,_regionId)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId) > 0']
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedPixelPrice(_regionId,pixelPrice)', 'BdpOwnership.clearApprovalAndTransfer(_contracts,BdpOwnership.ownerOf(_contracts,_regionId),msg.sender,_regionId)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId) > 0', 'etherToPreviousOwner = regionPrice * 19 / 20', 'BdpOwnership.ownerOf(_contracts,_regionId).transfer(etherToPreviousOwner)', 'forwardUpdateFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardUpdateFeesTo()']
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedPixelPrice(_regionId,pixelPrice)', 'BdpOwnership.clearApprovalAndTransfer(_contracts,BdpOwnership.ownerOf(_contracts,_regionId),msg.sender,_regionId)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId) > 0', 'etherToPreviousOwner = regionPrice * 19 / 20', 'BdpOwnership.ownerOf(_contracts,_regionId).transfer(etherToPreviousOwner)', 'forwardUpdateFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardUpdateFeesTo()']
		contract: BdpTransfer | function: purchase(address[16],uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'pixelPrice = BdpCalculator.calculateRegionSalePixelPrice(_contracts,_regionId)', 'None', '(area) = BdpCalculator.calculateArea(_contracts,_regionId)', 'regionPrice = pixelPrice * area', 'require(bool)(msg.value >= regionPrice)', 'msg.value > regionPrice', 'change = msg.value - regionPrice', 'msg.sender.transfer(change)', 'None', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionCurrentPixelPrice(_regionId,pixelPrice)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionBlockUpdatedAt(_regionId,block.number)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionUpdatedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedAt(_regionId,block.timestamp)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).setRegionPurchasedPixelPrice(_regionId,pixelPrice)', 'BdpOwnership.clearApprovalAndTransfer(_contracts,BdpOwnership.ownerOf(_contracts,_regionId),msg.sender,_regionId)', 'BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId) > 0', 'forwardPurchaseFeesTo = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getForwardPurchaseFeesTo()']
[cfg_Reentrancy in] contract: BdpTransfer . function: purchase(address[16],uint256) | Reentrancy\test3704.sol#1080-1113
./Reentrancy\test3704.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy\test3714.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3714.sol
Start Contract AcceptsProof
	To analyze：AcceptsProof.AcceptsProof(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Proof
	To analyze：Proof.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.reinvest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.exit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.transferAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.totalEthereumBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.myTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.myDividends(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.dividendsOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.sellPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.buyPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.calculateTokensReceived(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.calculateEthereumReceived(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.purchaseInternal(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.purchaseTokens(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.ethereumToTokens_(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.tokensToEthereum_(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Proof.sqrt(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3721.sol
Start Contract ERC20Basic
Start Contract ERC20
Start Contract SafeERC20
	To analyze：SafeERC20.safeTransfer(ERC20Basic,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeERC20.safeTransferFrom(ERC20,address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeERC20.safeApprove(ERC20,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenVesting
	To analyze：TokenVesting.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.TokenVesting(address,uint256,uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.release(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.revoke(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.releasableAmount(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenVesting.vestedAmount(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract CanReclaimToken
	To analyze：CanReclaimToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CanReclaimToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CanReclaimToken.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
Start Contract KYCBase
	To analyze：KYCBase.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCBase.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract ICOEngineInterface
Start Contract CrowdsaleBase
	To analyze：CrowdsaleBase.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.CrowdsaleBase(uint256,uint256,uint256,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.started()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.ended()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.startTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.endTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.totalTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.releaseTokensTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.forwardFunds(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleBase.validPurchase()
		cfg分析安全，所以开始ICFG的分析
Start Contract Reservation
	To analyze：Reservation.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.CrowdsaleBase(uint256,uint256,uint256,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.started()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.ended()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.startTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.endTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.totalTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.releaseTokensTo(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Reservation | function: releaseTokensTo(address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'require(bool)(validPurchase())', 'None', 'None', 'weiAmount = msg.value', 'tokenAmount = weiAmount.mul(price())', 'tokenAmount >= availableTokens', 'capReached = true', 'overflowTokens = tokenAmount.sub(availableTokens)', 'tokenAmount = tokenAmount.sub(overflowTokens)', 'refundWeiAmount = overflowTokens.div(price())', 'weiAmount = weiAmount.sub(refundWeiAmount)', 'buyer.transfer(refundWeiAmount)', 'None', 'weiRaised = weiRaised.add(weiAmount)', 'tokensSold = tokensSold.add(tokenAmount)', 'availableTokens = availableTokens.sub(tokenAmount)', 'mintTokens(buyer,tokenAmount)', [['taint', 'mintTokens(address,uint256)']]]
[Icfg_Reentrancy in] contract: Reservation . function: releaseTokensTo(address) | Reentrancy\test3728.sol#589-614
	To analyze：Reservation.forwardFunds(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.Reservation(address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.setCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.price()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reservation.mintTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BasicToken
	To analyze：BasicToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MintableToken
	To analyze：MintableToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.mint(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableToken.finishMinting()
		cfg分析安全，所以开始ICFG的分析
Start Contract PausableToken
	To analyze：PausableToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PausableToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract UacToken
	To analyze：UacToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.mint(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.finishMinting()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacToken.UacToken()
		cfg分析安全，所以开始ICFG的分析
Start Contract UbiatarPlayVault
	To analyze：UbiatarPlayVault.UbiatarPlayVault(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UbiatarPlayVault.release()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UbiatarPlayVault.releasableAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UbiatarPlayVault.vestedAmount()
		cfg分析安全，所以开始ICFG的分析
Start Contract UacCrowdsale
	To analyze：UacCrowdsale.KYCBase(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.buyTokensFor(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.buyTokens(uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.buyImplementation(address,uint64,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.reclaimToken(ERC20Basic)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.CrowdsaleBase(uint256,uint256,uint256,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.started()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.ended()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.startTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.endTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.totalTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.senderAllowedFor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.releaseTokensTo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.forwardFunds(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.validPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.UacCrowdsale(address,address,address,address,address,address,address,address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.mintPreAllocatedTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.initPresaleTokenVault(address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.price()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.mintReservationTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.mintTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.closeCrowdsale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：UacCrowdsale.finalise()
		cfg分析安全，所以开始ICFG的分析
Start Contract PresaleTokenVault
	To analyze：PresaleTokenVault.init(address[],uint256[],uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.release(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.release()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.releasableAmount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleTokenVault.vestedAmount(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3728.sol
Start Contract IStdToken
Start Contract EtheramaCommon
	To analyze：EtheramaCommon.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCommon.isManager(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaGasPriceLimit
	To analyze：EtheramaGasPriceLimit.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaGasPriceLimit.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaCore
	To analyze：EtheramaCore.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMaxGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.removeControllerContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.changeControllerContract(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setBigPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setQuickPromoInterval(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setPromoMinPurchaseEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setMinRefEthPurchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setTotalIncomeFeePercent(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.setRewardPercentages(uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutQuickBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.payoutBigBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawDevReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBonusPerShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserRewardPayouts(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserRefBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserRewardPayouts(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.resetUserPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackBuy(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackSell(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.trackTotalVolume(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getBuyCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getSellCount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeEth(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalVolumeToken(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserEthVolumeSaldo(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserQuickPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserBigPromoBonus(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTokenLocalBalance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.addUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.subUserTokenLocalBalance(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserReward(address,address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getUserTotalReward(address,bool,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserReward(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserTotalReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserShareBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.isRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawUserReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.getRewardAndPrepareWithdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.withdrawRemainingEthAfterAll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.calcPercent(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convertRealTo256(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaCore.convert256ToReal(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtheramaData
	To analyze：EtheramaData.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.init()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isInited()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCoreAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setNewControllerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getAdministratorCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.isAdministrator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCommonInitBlockNum()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.resetTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setTotalSupply(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setRealTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTokenLocalBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getActualUserTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRewardPayouts(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserRefBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserReward(address,bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserTotalPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserBigPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserQuickPromoBonus(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtheramaData.getUserEthVolumeSaldo(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherama
	To analyze：Etherama.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.removeAdministator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.transferOwnershipRequest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.setHasMaxPurchaseLimit(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.activate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.finish()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.buy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sell(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.transferTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.withdrawTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.prepareForMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMaxGasPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getExpirationTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTimeTillExpiration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserAdministrator()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDataContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.requestControllerContractMigration(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.approveControllerContractMigration()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.migrateToNewNewControllerContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBuyCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getSellCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalVolumeToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBonusPerShare()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenInitialPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getDevRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getShareRewardPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRefBonusPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoBlockInterval()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPromoMinPurchaseEth()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedPercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getPriceSpeedTokenBlock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getMinRefEthPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalCollectedPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentTokenPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalEthBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRemainingTokenAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTotalTokenSold()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserLocalTokenBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserLocalTokenBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.isCurrentUserRefAvailable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserRefBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getEthDealRange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserReward(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenSellPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.get1TokenBuyPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateBuyOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.estimateSellOrder(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getUserMaxPurchase(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserMaxPurchase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getTokenOwnerReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserTotalPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getCurrentUserQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBlockNumSinceInit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getQuickPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getBigPromoRemainingBlocks()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.purchaseTokens(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.setTotalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.checkAndSendPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendQuickPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.sendBigPromoBonus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.distributeFee(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addProfitPerShare(uint256,address)
		cfg分析安全，所以开始ICFG的分析
		contract: Etherama | function: addProfitPerShare(uint256,address) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'refBonus = calcRefBonus(totalFeeEth)', 'totalShareReward = calcTotalShareRewardFee(totalFeeEth)', 'refAddress != address(0x0)', '_core.addUserRefBalance.value(refBonus)(refAddress)', 'None', 'getTotalTokenSold() == 0', '_core.addBonusPerShare.value(totalShareReward)()', [['taint', 'addBonusPerShare()']]]
[Icfg_Reentrancy in] contract: Etherama . function: addProfitPerShare(uint256,address) | Reentrancy\test3730.sol#1362-1377
	To analyze：Etherama.addDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.addUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.subUserTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.updateTokenPrice(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.ethToTokens(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.tokensToEth(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalFee(uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calc1RealTokenRateFromRealTokens(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.getRealPriceSpeed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTotalShareRewardFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcRefBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcTokenOwnerReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcDevReward(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcQuickPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherama.calcBigPromoBonus(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract RealMath
	To analyze：RealMath.getMinInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.getMaxInt64()
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt256ValidIn64(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt256ValidIn64(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isUInt64ValidIn64(uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.isInt128ValidIn64(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.toReal(int64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fromReal(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.abs(int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fpartSigned(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipart(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.mul(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.div(int128,int128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.fraction(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ipow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.hibit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.findbit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.rescale(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.lnLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.ln(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.expLimited(int256,int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.exp(int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RealMath.pow(int256,int256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3730.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract TokenController
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Contribution
	To analyze：Contribution.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.Contribution(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.initialize(address,address,address,address,address,address,address,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelistAddresses(address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.whitelist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.blacklist(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.exchangeRate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.tokensToGenerate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.allowTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.doBuy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.finalize()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.weiToCollectByInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockNumber()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.getBlockTimestamp()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Contribution.pauseContribution(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract DevTokensHolder
	To analyze：DevTokensHolder.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.DevTokensHolder(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.collectTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.extractablePercentage()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.months(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.getTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DevTokensHolder.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3755.sol
Start Contract WhaleGiveaway2
	To analyze：WhaleGiveaway2.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.GetFreebie()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WhaleGiveaway2.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3763.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.assert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Token
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ReserveToken
	To analyze：ReserveToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.ReserveToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.create(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.destroy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevels
	To analyze：AccountLevels.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevelsTest
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.setAccountLevel(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherDelta
	To analyze：EtherDelta.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.EtherDelta(address,address,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeAccountLevelsAddr(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeAccount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeMake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeTake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeRebate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.withdraw(uint256)
		contract: EtherDelta | function: withdraw(uint256) | accessPermision: False | 锁: True | 钱提前更新：False
			path: ['entryPoint', 'tokens[0][msg.sender] < amount', 'None', 'tokens[0][msg.sender] = amount', 'tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)', '! msg.sender.call.value(amount)()']
[cfg_Reentrancy in] contract: EtherDelta . function: withdraw(uint256) | Reentrancy\test3766.sol#219-225
	To analyze：EtherDelta.depositToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.balanceOf(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.order(address,uint256,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.tradeBalances(address,uint256,address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3766.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract DiceGame
	To analyze：DiceGame.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.setSecretSigner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.setMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.addBankerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.setInvite(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.batchSetInvite(address[],uint256[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.getPlayerAddr(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.createInviteID(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.getPlayerId(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.setMaxProfit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.setOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.placeBet(uint8,bool,uint256,uint256,bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.getDiceWinAmount(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.refundBet(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.settleUncle(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.settleBet(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.settle(DiceGame.Bet,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.safeSendFunds(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.playerWithdrawPendingTransactions()
		contract: DiceGame | function: playerWithdrawPendingTransactions() | accessPermision: False | 锁: False | 钱提前更新：True
			path: ['entryPoint', 'withdrawAmount = playerPendingWithdrawals[msg.sender]', 'require(bool)(withdrawAmount > 0)', 'playerPendingWithdrawals[msg.sender] = 0', 'msg.sender.call.value(withdrawAmount)()']
[cfg_Reentrancy in] contract: DiceGame . function: playerWithdrawPendingTransactions() | Reentrancy\test3877.sol#297-307
	To analyze：DiceGame.pendingWithdrawalsBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.inviteProfit(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.houseWithdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DiceGame.ownerkill()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3877.sol
Start Contract NeuroDAO
Start Contract owned
	To analyze：owned.owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：owned.changeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：owned.confirmOwner()
		cfg分析安全，所以开始ICFG的分析
Start Contract Crowdsale
	To analyze：Crowdsale.owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.changeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.confirmOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.Crowdsale(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.setEtherPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.startPresale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.startBonuses()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.finishCrowdsale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract Token
	To analyze：Token.owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.changeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.confirmOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.Crowdsale(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.setEtherPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.startPresale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.startBonuses()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.finishCrowdsale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.Token(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PresaleBREMP
	To analyze：PresaleBREMP.owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.changeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.confirmOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.Crowdsale(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.setEtherPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.startPresale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.startBonuses()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.finishCrowdsale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.Token(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.PresaleBREMP(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PresaleBREMP.killMe()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test3883.sol
Start Contract IBancorConverterExtensions
	To analyze：IBancorConverterExtensions.formula()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IBancorConverterExtensions.gasPriceLimit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IBancorConverterExtensions.quickConverter()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorFormula
Start Contract IBancorGasPriceLimit
	To analyze：IBancorGasPriceLimit.gasPrice()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorQuickConverter
Start Contract IERC20Token
	To analyze：IERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract IOwned
	To analyze：IOwned.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenHolder
	To analyze：ITokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract IEtherToken
	To analyze：IEtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISmartToken
	To analyze：ISmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenConverter
Start Contract Owned
	To analyze：Owned.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
Start Contract Utils
	To analyze：Utils.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenHolder
	To analyze：TokenHolder.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartTokenController
	To analyze：SmartTokenController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Managed
	To analyze：Managed.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorConverter
	To analyze：BancorConverter.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.BancorConverter(ISmartToken,IBancorConverterExtensions,uint32,IERC20Token,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.connectorTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.convertibleTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.convertibleToken(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.setExtensions(IBancorConverterExtensions)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.setQuickBuyPath(IERC20Token[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.clearQuickBuyPath()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.getQuickBuyPathLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.disableConversions(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.setConversionFee(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.getConversionFeeAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.addConnector(IERC20Token,uint32,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.updateConnector(IERC20Token,uint32,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.disableConnectorPurchases(IERC20Token,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.getConnectorBalance(IERC20Token)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.getReturn(IERC20Token,IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.getPurchaseReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.getSaleReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.convert(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.buy(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.sell(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.quickConvert(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.change(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.getSaleReturn(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.dispatchConversionEvent(IERC20Token,uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverter.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorConverterExtensions
	To analyze：BancorConverterExtensions.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.formula()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.gasPriceLimit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.quickConverter()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.BancorConverterExtensions(IBancorFormula,IBancorGasPriceLimit,IBancorQuickConverter)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.setFormula(IBancorFormula)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.setGasPriceLimit(IBancorGasPriceLimit)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorConverterExtensions.setQuickConverter(IBancorQuickConverter)
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorFormula
	To analyze：BancorFormula.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.BancorFormula()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.calculatePurchaseReturn(uint256,uint256,uint32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.calculateSaleReturn(uint256,uint256,uint32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.power(uint256,uint256,uint32,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.ln(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.floorLog2(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.findPositionInMaxExpArray(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorFormula.fixedExp(uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorGasPriceLimit
	To analyze：BancorGasPriceLimit.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.gasPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.BancorGasPriceLimit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorGasPriceLimit.setGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorPriceFloor
	To analyze：BancorPriceFloor.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.BancorPriceFloor(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.sell()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorPriceFloor.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorQuickConverter
	To analyze：BancorQuickConverter.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.BancorQuickConverter()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.registerEtherToken(IEtherToken,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.convertFor(IERC20Token[],uint256,uint256,address)
		contract: BancorQuickConverter | function: convertFor(IERC20Token[],uint256,uint256,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()']
		contract: BancorQuickConverter | function: convertFor(IERC20Token[],uint256,uint256,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()', 'None', 'i = 1', 'None', 'i < pathLength', 'smartToken = ISmartToken(_path[i])', 'toToken = _path[i + 1]', 'converter = ITokenConverter(smartToken.owner())']
		contract: BancorQuickConverter | function: convertFor(IERC20Token[],uint256,uint256,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()', 'None', 'i = 1', 'None', 'i < pathLength', 'None', 'etherTokens[toToken]', 'IEtherToken(toToken).withdrawTo(_for,_amount)']
		contract: BancorQuickConverter | function: convertFor(IERC20Token[],uint256,uint256,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()', 'None', 'i = 1', 'None', 'i < pathLength', 'None', 'etherTokens[toToken]', 'assert(bool)(toToken.transfer(_for,_amount))']
		contract: BancorQuickConverter | function: convertFor(IERC20Token[],uint256,uint256,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()', 'None', 'i = 1', 'None', 'i < pathLength', 'smartToken = ISmartToken(_path[i])', 'toToken = _path[i + 1]', 'converter = ITokenConverter(smartToken.owner())', 'smartToken != fromToken', 'ensureAllowance(fromToken,converter,_amount)', 'None', 'i == pathLength - 2', '_amount = converter.change(fromToken,toToken,_amount,_minReturn)']
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()', 'None', 'i = 1', 'None', 'i < pathLength', 'smartToken = ISmartToken(_path[i])', 'toToken = _path[i + 1]', 'converter = ITokenConverter(smartToken.owner())', 'smartToken != fromToken', 'None', 'i == pathLength - 2', '_amount = converter.change(fromToken,toToken,_amount,_minReturn)']
		contract: BancorQuickConverter | function: convertFor(IERC20Token[],uint256,uint256,address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()', 'None', 'i = 1', 'None', 'i < pathLength', 'smartToken = ISmartToken(_path[i])', 'toToken = _path[i + 1]', 'converter = ITokenConverter(smartToken.owner())', 'smartToken != fromToken', 'ensureAllowance(fromToken,converter,_amount)', 'None', 'i == pathLength - 2', '_amount = converter.change(fromToken,toToken,_amount,1)']
			path: ['entryPoint', 'fromToken = _path[0]', 'require(bool)(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]))', 'None', 'None', 'None', 'pathLength = _path.length', 'msg.value > 0', 'IEtherToken(fromToken).deposit.value(msg.value)()', 'None', 'i = 1', 'None', 'i < pathLength', 'smartToken = ISmartToken(_path[i])', 'toToken = _path[i + 1]', 'converter = ITokenConverter(smartToken.owner())', 'smartToken != fromToken', 'None', 'i == pathLength - 2', '_amount = converter.change(fromToken,toToken,_amount,1)']
[cfg_Reentrancy in] contract: BancorQuickConverter . function: convertFor(IERC20Token[],uint256,uint256,address) | Reentrancy\test407.sol#1527-1571
	To analyze：BancorQuickConverter.claimAndConvertFor(IERC20Token[],uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.convert(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.claimAndConvert(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorQuickConverter.ensureAllowance(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CrowdsaleController
	To analyze：CrowdsaleController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.CrowdsaleController(ISmartToken,uint256,address,address,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.computeRealCap(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.enableRealCap(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.computeReturn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.contributeETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.contributeBTCs()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.processContribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CrowdsaleController.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Token
	To analyze：ERC20Token.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.ERC20Token(string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC20Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherToken
	To analyze：EtherToken.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.ERC20Token(string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.EtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.withdrawTo(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartToken
	To analyze：SmartToken.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.ERC20Token(string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.SmartToken(string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.disableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.issue(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.destroy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test407.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Dice
	To analyze：Dice.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.Dice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.numBets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMinBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getMaxBetAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getLossesShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getProfitShare(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.getBalance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.searchSmallestInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeProofType(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOraclizeConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.safeSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.addInvestorAtID(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.profitDistribution()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.bet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isWinningBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.isLosingBet(Dice.Bet,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.increaseInvestment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.newInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.divest(address)
		cfg分析安全，所以开始ICFG的分析
		contract: Dice | function: divest(address) | accessPermision: True | publicCaller: True | 锁/钱提前更新：False
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
			path：['None', 'profitDistribution()', 'currentID = investorIDs[currentInvestor]', 'amountToReturn = getBalance(currentInvestor)', '(invested >= investors[currentID].amountInvested)', 'invested -= investors[currentID].amountInvested', 'divestFeeAmount = (amountToReturn * divestFee) / 10000', 'amountToReturn -= divestFeeAmount', 'delete investors[currentID]', 'delete investorIDs[currentInvestor]', 'currentID != numInvestors', 'lastInvestor = investors[numInvestors]', 'investorIDs[lastInvestor.investorAddress] = currentID', 'investors[currentID] = lastInvestor', 'delete investors[numInvestors]', 'None', 'numInvestors --', 'safeSend(currentInvestor,amountToReturn)', 'safeSend(houseAddress,divestFeeAmount)', [['taint', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)'], ['eth', 'safeSend(address,uint256)']]]
[Icfg_Reentrancy in] contract: Dice . function: divest(address) | Reentrancy\test470.sol#820-856
	To analyze：Dice.forceDivestOfAllInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.forceDivestOfOneInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.stopContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.resumeContract()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeHouseAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeOwnerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.changeGasLimitOfSafeSend(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.voteEmergencyWithdrawal(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.proposeEmergencyWithdrawal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Dice.executeEmergencyWithdrawal()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test470.sol
Start Contract Owned
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenRecipient
Start Contract TokenERC20
	To analyze：TokenERC20.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinToken
	To analyze：MifflinToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: MifflinToken . function: contribution(uint256) | Reentrancy\test487.sol#216-233
	To analyze：MifflinToken.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BeetBuck
	To analyze：BeetBuck.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: BeetBuck . function: contribution(uint256) | Reentrancy\test487.sol#216-233
	To analyze：BeetBuck.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.BeetBuck(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NapNickel
	To analyze：NapNickel.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NapNickel . function: contribution(uint256) | Reentrancy\test487.sol#216-233
	To analyze：NapNickel.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.NapNickel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isLeapYear(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.leapYearsBefore(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDaysInMonth(uint8,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestampParts(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestamp(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getYear(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMonth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDay(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getHour(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMinute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getSecond(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getWeekday(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract QuabityQuarter
	To analyze：QuabityQuarter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: QuabityQuarter . function: contribution(uint256) | Reentrancy\test487.sol#216-233
	To analyze：QuabityQuarter.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.QuabityQuarter(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract KelevinKoin
	To analyze：KelevinKoin.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: KelevinKoin . function: contribution(uint256) | Reentrancy\test487.sol#216-233
	To analyze：KelevinKoin.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.KelevinKoin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NnexNote
	To analyze：NnexNote.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NnexNote . function: contribution(uint256) | Reentrancy\test487.sol#216-233
	To analyze：NnexNote.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.NnexNote(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract DundieDollar
	To analyze：DundieDollar.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: DundieDollar . function: contribution(uint256) | Reentrancy\test487.sol#216-233
	To analyze：DundieDollar.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.DundieDollar(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addAward(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardBalanceOf(address,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardName(uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinMarket
	To analyze：MifflinMarket.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.MifflinMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setToken(uint8,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeToken(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setActive(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getRewardToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenById(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensByAddress(uint256,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensById(uint256,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.highContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.lowContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test487.sol
Start Contract MarketPrice
	To analyze：MarketPrice.MarketPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.getToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.ETH(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.USD(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.EUR(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.GBP(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.updatedAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.update(uint256,string,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.deleteToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.changeCreator(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.changeSender(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.execute(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.requestUpdate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketPrice.donate()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test509.sol
Start Contract ERC20
Start Contract EnjinBuyer
	To analyze：EnjinBuyer.set_sale_address(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.activate_kill_switch(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.withdraw(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.add_to_buy_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.add_to_withdraw_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.claim_bounty()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EnjinBuyer.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test524.sol
Start Contract PrivateBank
	To analyze：PrivateBank.PrivateBank(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateBank.Deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PrivateBank.CashOut(uint256)
		contract: PrivateBank | function: CashOut(uint256) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', '_am <= balances[msg.sender]', 'msg.sender.call.value(_am)()']
[cfg_Reentrancy in] contract: PrivateBank . function: CashOut(uint256) | Reentrancy\test554.sol#27-37
	To analyze：PrivateBank.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract Log
	To analyze：Log.AddMessage(address,uint256,string)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test554.sol
Start Contract SafeMath
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract ERC20Interface
Start Contract Owned
	To analyze：Owned.owned()
		cfg分析安全，所以开始ICFG的分析
Start Contract METADOLLAR
	To analyze：METADOLLAR.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.STARTMETADOLLAR()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.calculateTheEndPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkFrozenAccounts(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.buy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.sell2(address)
		contract: METADOLLAR | function: sell2(address) | accessPermision: False | 锁: True | 钱提前更新：True
			path: ['entryPoint', 'token = METADOLLAR(_tokenAddress)', 'tokens = msg.value * sellPrice', 'require(bool)(token.balanceOf(this) >= tokens)', 'commission = msg.value / commissionRate', 'require(bool)(address(this).send(commission))', 'token.transfer(msg.sender,tokens)']
[cfg_Reentrancy in] contract: METADOLLAR . function: sell2(address) | Reentrancy\test568.sol#219-226
	To analyze：METADOLLAR.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkMinimalGoal()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.checkIcoStatus()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.buyToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.updatePrices()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setICOPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setSellRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setCommissionRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setDolRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.setEthRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.mintToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.destroyToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.collect()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：METADOLLAR.stopThisIco(bool)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test568.sol
Start Contract Utils
	To analyze：Utils.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IOwned
	To analyze：IOwned.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract Owned
	To analyze：Owned.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
Start Contract Managed
	To analyze：Managed.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenHolder
	To analyze：ITokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenHolder
	To analyze：TokenHolder.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartTokenController
	To analyze：SmartTokenController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC20Token
	To analyze：IERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract IEtherToken
	To analyze：IEtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISmartToken
	To analyze：ISmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorFormula
Start Contract ITokenChanger
Start Contract BancorChanger
	To analyze：BancorChanger.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.BancorChanger(ISmartToken,IBancorFormula,uint32,IERC20Token,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.reserveTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableToken(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setFormula(IBancorFormula)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setQuickBuyPath(IERC20Token[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.clearQuickBuyPath()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyPathLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.hasQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableChanging(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setChangeFee(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getChangeFeeAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.addReserve(IERC20Token,uint32,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.updateReserve(IERC20Token,uint32,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableReservePurchases(IERC20Token,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReserveBalance(IERC20Token)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReturn(IERC20Token,IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getPurchaseReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.change(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.buy(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.sell(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickChange(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickBuy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.ensureAllowance(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.claimTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test587.sol
Start Contract ERC223LegacyCallbackCompat
	To analyze：ERC223LegacyCallbackCompat.onTokenTransfer(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract KnownContracts
Start Contract KnownInterfaces
Start Contract Math
	To analyze：Math.absDiff(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.divRound(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.decimalFraction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.proportion(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Math.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IAccessPolicy
Start Contract IAccessControlled
Start Contract StandardRoles
Start Contract AccessControlled
	To analyze：AccessControlled.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControlled.setAccessPolicy(IAccessPolicy,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControlled.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
Start Contract IsContract
	To analyze：IsContract.isContract(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessRoles
Start Contract IBasicToken
Start Contract Reclaimable
	To analyze：Reclaimable.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reclaimable.setAccessPolicy(IAccessPolicy,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reclaimable.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Reclaimable.reclaim(IBasicToken)
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenMetadata
Start Contract TokenMetadata
	To analyze：TokenMetadata.constructor(string,uint8,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenMetadata.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenMetadata.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenMetadata.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenMetadata.version()
		cfg分析安全，所以开始ICFG的分析
Start Contract MTokenAllowanceController
Start Contract MTokenTransferController
Start Contract MTokenController
Start Contract TrustlessTokenController
	To analyze：TrustlessTokenController.mOnTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TrustlessTokenController.mOnApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC20Allowance
Start Contract IERC20Token
Start Contract IERC677Callback
Start Contract IERC677Allowance
Start Contract IERC677Token
Start Contract MTokenTransfer
Start Contract BasicToken
	To analyze：BasicToken.absDiff(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.divRound(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.decimalFraction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.proportion(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenAllowance
	To analyze：TokenAllowance.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenAllowance.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenAllowance.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenAllowance.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenAllowance.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenAllowance.mAllowanceOverride(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.mAllowanceOverride(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.absDiff(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.divRound(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.decimalFraction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.proportion(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IContractId
Start Contract IERC223Callback
Start Contract IERC223Token
Start Contract IWithdrawableToken
Start Contract EtherToken
	To analyze：EtherToken.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.setAccessPolicy(IAccessPolicy,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.reclaim(IBasicToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.constructor(string,uint8,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.version()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.mOnTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.mOnApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.mAllowanceOverride(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.absDiff(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.divRound(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.decimalFraction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.proportion(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.depositAndTransfer(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.withdrawAndSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.transfer(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.reclaim(IBasicToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.contractId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.depositPrivate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherToken.withdrawPrivate(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IEthereumForkArbiter
Start Contract IAgreement
Start Contract Agreement
	To analyze：Agreement.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.setAccessPolicy(IAccessPolicy,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.constructor(IAccessPolicy,IEthereumForkArbiter)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.amendAgreement(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.ethereumForkArbiter()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.currentAgreement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.pastAgreement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.agreementSignedAtBlock(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.amendmentsCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.acceptAgreementInternal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Agreement.mCanAmend(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenController
Start Contract ITokenControllerHook
Start Contract EuroToken
	To analyze：EuroToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.constructor(string,uint8,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.version()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mAllowanceOverride(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.absDiff(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.divRound(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.decimalFraction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.proportion(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.setAccessPolicy(IAccessPolicy,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.constructor(IAccessPolicy,IEthereumForkArbiter)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.amendAgreement(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.ethereumForkArbiter()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.currentAgreement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.pastAgreement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.agreementSignedAtBlock(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.amendmentsCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.acceptAgreementInternal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mCanAmend(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.constructor(IAccessPolicy,IEthereumForkArbiter,ITokenController)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.deposit(address,uint256,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.depositMany(address[],uint256[],bytes32[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.settleWithdraw(address,uint256,uint256,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.destroy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.changeTokenController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.tokenController()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.transfer(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.depositAndTransfer(address,address,uint256,uint256,bytes,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.contractId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mOnTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mOnApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mAllowanceOverride(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.mCanAmend(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.destroyTokensPrivate(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EuroToken.ierc223TransferInternal(address,address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PlatformTerms
	To analyze：PlatformTerms.absDiff(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.divRound(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.decimalFraction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.proportion(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.calculateNeumarkDistribution(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.calculatePlatformTokenFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.calculatePlatformFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PlatformTerms.contractId()
		cfg分析安全，所以开始ICFG的分析
Start Contract Serialization
	To analyze：Serialization.decodeAddress(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Serialization.decodeAddressUInt256(bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC223LegacyCallback
Start Contract IFeeDisbursal
Start Contract IFeeDisbursalController
Start Contract ITokenSnapshots
Start Contract IdentityRecord
	To analyze：IdentityRecord.deserializeClaims(bytes32)
		cfg分析安全，所以开始ICFG的分析
Start Contract IIdentityRegistry
Start Contract NeumarkIssuanceCurve
	To analyze：NeumarkIssuanceCurve.incremental(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NeumarkIssuanceCurve.incrementalInverse(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NeumarkIssuanceCurve.incrementalInverse(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NeumarkIssuanceCurve.cumulative(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NeumarkIssuanceCurve.cumulativeInverse(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NeumarkIssuanceCurve.neumarkCap()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NeumarkIssuanceCurve.initialRewardFraction()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISnapshotable
Start Contract MSnapshotPolicy
Start Contract Daily
	To analyze：Daily.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Daily.snapshotAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Daily.mAdvanceSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Daily.mCurrentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Daily.dayBase(uint128)
		cfg分析安全，所以开始ICFG的分析
Start Contract DailyAndSnapshotable
	To analyze：DailyAndSnapshotable.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.snapshotAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.mAdvanceSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.mCurrentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.dayBase(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.createSnapshot()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.mAdvanceSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DailyAndSnapshotable.mCurrentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
Start Contract Snapshot
	To analyze：Snapshot.hasValue(Snapshot.Values[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Snapshot.hasValueAt(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Snapshot.getValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Snapshot.getValueAt(Snapshot.Values[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Snapshot.setValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IClonedTokenParent
Start Contract BasicSnapshotToken
	To analyze：BasicSnapshotToken.hasValue(Snapshot.Values[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.hasValueAt(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.getValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.getValueAt(Snapshot.Values[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.setValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.currentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.parentToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.parentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.allBalancesOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.totalSupplyAtInternal(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.balanceOfAtInternal(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicSnapshotToken.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MTokenMint
Start Contract MintableSnapshotToken
	To analyze：MintableSnapshotToken.hasValue(Snapshot.Values[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.hasValueAt(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.getValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.getValueAt(Snapshot.Values[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.setValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.currentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.parentToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.parentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.allBalancesOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.totalSupplyAtInternal(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.balanceOfAtInternal(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.mGenerateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MintableSnapshotToken.mDestroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardSnapshotToken
	To analyze：StandardSnapshotToken.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.mAllowanceOverride(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.hasValue(Snapshot.Values[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.hasValueAt(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.getValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.getValueAt(Snapshot.Values[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.setValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.currentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.parentToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.parentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.allBalancesOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.totalSupplyAtInternal(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.balanceOfAtInternal(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.mGenerateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.mDestroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardSnapshotToken.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Neumark
	To analyze：Neumark.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.setAccessPolicy(IAccessPolicy,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.reclaim(IBasicToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.incremental(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.incrementalInverse(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.incrementalInverse(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.cumulative(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.cumulativeInverse(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.neumarkCap()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.initialRewardFraction()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(string,uint8,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.version()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mAllowanceOverride(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.hasValue(Snapshot.Values[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.hasValueAt(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.getValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.getValueAt(Snapshot.Values[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.setValue(Snapshot.Values[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.currentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.parentToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.parentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.allBalancesOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.totalSupplyAtInternal(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.balanceOfAtInternal(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mGenerateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mDestroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(IClonedTokenParent,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.snapshotAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mAdvanceSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mCurrentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.dayBase(uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.createSnapshot()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mAdvanceSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mCurrentSnapshotId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(IAccessPolicy,IEthereumForkArbiter)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.amendAgreement(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.ethereumForkArbiter()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.currentAgreement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.pastAgreement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.agreementSignedAtBlock(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.amendmentsCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.acceptAgreementInternal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mCanAmend(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.constructor(IAccessPolicy,IEthereumForkArbiter)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.issueForEuro(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.distribute(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.burn(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.enableTransfer(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.createSnapshot()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.transferEnabled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.totalEuroUlps()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.incremental(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.transfer(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mOnTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.mOnApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Neumark.burnPrivate(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IPlatformPortfolio
Start Contract ITokenExchangeRateOracle
Start Contract Universe
	To analyze：Universe.constructor(IAccessPolicy)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setAccessPolicy(IAccessPolicy,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.constructor(IAccessPolicy,IEthereumForkArbiter)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.amendAgreement(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.ethereumForkArbiter()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.currentAgreement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.pastAgreement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.agreementSignedAtBlock(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.amendmentsCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.acceptAgreementInternal(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.mCanAmend(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.constructor(IAccessPolicy,IEthereumForkArbiter)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.getSingleton(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.getManySingletons(bytes4[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.isSingleton(bytes4,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.isInterfaceCollectionInstance(bytes4,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.isAnyOfInterfaceCollectionInstance(bytes4[],address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.getInterfacesOfInstance(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setSingleton(bytes4,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setManySingletons(bytes4[],address[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setCollectionInterface(bytes4,address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setInterfaceInManyCollections(bytes4[],address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setCollectionsInterfaces(bytes4[],address[],bool[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.contractId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.accessPolicy()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.forkArbiter()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.neumark()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.etherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.euroToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.etherLock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.euroLock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.icbmEtherLock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.icbmEuroLock()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.identityRegistry()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.tokenExchangeRateOracle()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.feeDisbursal()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.platformPortfolio()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.tokenExchange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.gasExchange()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.platformTerms()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setSingletonPrivate(bytes4,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.setCollectionPrivate(bytes4,address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.addInstance(address,bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Universe.dropInstance(address,bytes4)
		cfg分析安全，所以开始ICFG的分析
Start Contract FeeDisbursal
	To analyze：FeeDisbursal.absDiff(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.divRound(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.decimalFraction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.proportion(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.max(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.decodeAddress(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.decodeAddressUInt256(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.onTokenTransfer(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.constructor(Universe,IFeeDisbursalController)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.getDisbursal(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.getNonClaimableDisbursals(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.getDisbursalCount(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.accept(address,ITokenSnapshots,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.acceptMultipleByToken(address[],ITokenSnapshots)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.acceptMultipleByProRataToken(address,ITokenSnapshots[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.reject(address,ITokenSnapshots,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.claimable(address,ITokenSnapshots,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.claimableMutipleByToken(address[],ITokenSnapshots,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.claimableMutipleByProRataToken(address,ITokenSnapshots[],address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.recycle(address,ITokenSnapshots,address[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.recycleable(address,ITokenSnapshots,address[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.feeDisbursalController()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.changeFeeDisbursalController(IFeeDisbursalController)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.tokenFallback(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.receiveApproval(address,uint256,address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.contractId()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.tokenFallbackPrivate(address,address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.disburse(address,address,uint256,ITokenSnapshots,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.claimPrivate(address,ITokenSnapshots,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.claimablePrivate(address,ITokenSnapshots,address,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：FeeDisbursal.calculateClaimableAmount(address,uint256,address,ITokenSnapshots,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test604.sol
Start Contract Owned
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenRecipient
Start Contract TokenERC20
	To analyze：TokenERC20.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenERC20.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinToken
	To analyze：MifflinToken.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinToken.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: MifflinToken | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: MifflinToken . function: contribution(uint256) | Reentrancy\test624.sol#216-233
	To analyze：MifflinToken.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BeetBuck
	To analyze：BeetBuck.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: BeetBuck | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: BeetBuck . function: contribution(uint256) | Reentrancy\test624.sol#216-233
	To analyze：BeetBuck.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.BeetBuck(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BeetBuck.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NapNickel
	To analyze：NapNickel.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: NapNickel | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NapNickel . function: contribution(uint256) | Reentrancy\test624.sol#216-233
	To analyze：NapNickel.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.NapNickel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.isLeapYear(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.leapYearsBefore(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDaysInMonth(uint8,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestampParts(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.parseTimestamp(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getYear(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMonth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getDay(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getHour(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getMinute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getSecond(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NapNickel.getWeekday(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract QuabityQuarter
	To analyze：QuabityQuarter.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: QuabityQuarter | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: QuabityQuarter . function: contribution(uint256) | Reentrancy\test624.sol#216-233
	To analyze：QuabityQuarter.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.QuabityQuarter(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：QuabityQuarter.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract KelevinKoin
	To analyze：KelevinKoin.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: KelevinKoin | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: KelevinKoin . function: contribution(uint256) | Reentrancy\test624.sol#216-233
	To analyze：KelevinKoin.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.KelevinKoin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KelevinKoin.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract NnexNote
	To analyze：NnexNote.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
		contract: NnexNote | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
[Icfg_Reentrancy in] contract: NnexNote . function: contribution(uint256) | Reentrancy\test624.sol#216-233
	To analyze：NnexNote.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.NnexNote(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NnexNote.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract DundieDollar
	To analyze：DundieDollar.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.TokenERC20(uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.MifflinToken(address,uint8,uint256,string,string,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.buy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.give(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.take(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.freezeAccount(address,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.setBuyPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.contribution(uint256)
		cfg分析安全，所以开始ICFG的分析
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'amount < lowestContribution', 'MifflinMarket(exchange).lowContributionAward(msg.sender)', [['taint', 'lowContributionAward(address)']]]
		contract: DundieDollar | function: contribution(uint256) | accessPermision: False | 锁/钱提前更新：False
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = fullper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
			path：['None', 'owner.transfer(msg.value)', 'totalContribution += msg.value', 'amount > highestContribution', 'oneper = buyPrice * 99 / 100', 'fullper = buyPrice * highestContribution / amount', 'fullper > oneper', 'buyPrice = oneper', 'None', 'highestContribution = amount', 'MifflinMarket(exchange).highContributionAward(msg.sender)', [['taint', 'highContributionAward(address)']]]
[Icfg_Reentrancy in] contract: DundieDollar . function: contribution(uint256) | Reentrancy\test624.sol#216-233
	To analyze：DundieDollar.sell(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.DundieDollar(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.addAward(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.transferAwards(address,address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardBalanceOf(address,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DundieDollar.awardName(uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract MifflinMarket
	To analyze：MifflinMarket.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.isOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.MifflinMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setToken(uint8,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.removeToken(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.setActive(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getRewardToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenById(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.getTokenByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensByAddress(uint256,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.exchangeTokensById(uint256,uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.highContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MifflinMarket.lowContributionAward(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test624.sol
Start Contract WinEthFree
	To analyze：WinEthFree.isInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.resetInvestor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.calcInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.withdrawInterest(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doInvest(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.WinnerNotReturn(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doBet(address,uint256,WinEthFree.WagerType)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.drawLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.random(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLuckyTickets()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.sort(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.quickSort(uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.payTicketsPrize(uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextWave()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.nextBet()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.takeCommission(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.doLeverageBet(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：WinEthFree.getLeverageAddress()
		cfg分析安全，所以开始ICFG的分析
Start Contract Leverage
	To analyze：Leverage.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Leverage.fallback()
		contract: Leverage | function: fallback() | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'value = msg.value', 'value > 0', 'address(mainContract).transfer(value)', 'None', 'value = uint256(value / minInvestment) * minInvestment', 'mainContract.doLeverageBet(msg.sender,value)']
[cfg_Reentrancy in] contract: Leverage . function: fallback() | Reentrancy\test672.sol#457-468
./Reentrancy\test672.sol
Start Contract Utils
	To analyze：Utils.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Utils.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IOwned
	To analyze：IOwned.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract Owned
	To analyze：Owned.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Owned.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
Start Contract Managed
	To analyze：Managed.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Managed.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
Start Contract ITokenHolder
	To analyze：ITokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenHolder
	To analyze：TokenHolder.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TokenHolder.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SmartTokenController
	To analyze：SmartTokenController.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SmartTokenController.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IERC20Token
	To analyze：IERC20Token.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IERC20Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract IEtherToken
	To analyze：IEtherToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：IEtherToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract ISmartToken
	To analyze：ISmartToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.decimals()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ISmartToken.owner()
		cfg分析安全，所以开始ICFG的分析
Start Contract IBancorFormula
Start Contract ITokenChanger
Start Contract BancorChanger
	To analyze：BancorChanger.Managed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferManagement(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptManagement()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Utils()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.owner()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.Owned()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.TokenHolder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.SmartTokenController(ISmartToken)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.transferTokenOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.acceptTokenOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableTokenTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.withdrawFromToken(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.BancorChanger(ISmartToken,IBancorFormula,uint32,IERC20Token,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.reserveTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableTokenCount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.changeableToken(uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setFormula(IBancorFormula)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setQuickBuyPath(IERC20Token[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.clearQuickBuyPath()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyPathLength()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.hasQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getQuickBuyEtherToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableChanging(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.setChangeFee(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getChangeFeeAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.addReserve(IERC20Token,uint32,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.updateReserve(IERC20Token,uint32,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.disableReservePurchases(IERC20Token,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReserveBalance(IERC20Token)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getReturn(IERC20Token,IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getPurchaseReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.change(IERC20Token,IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.buy(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.sell(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickChange(IERC20Token[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.quickBuy(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.getSaleReturn(IERC20Token,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.ensureAllowance(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.claimTokens(IERC20Token,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorChanger.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BancorLender
	To analyze：BancorLender.isCollateralWithinMargin(uint256,uint256,uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.offerToLend(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.takeOffer(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.addCollateral(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.returnLoan(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BancorLender.forceClose(uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test714.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ContributorApprover
	To analyze：ContributorApprover.ContributorApprover(KyberContributorWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ContributorApprover.saleStarted()
		cfg分析安全，所以开始ICFG的分析
Start Contract KyberNetworkTokenSale
	To analyze：KyberNetworkTokenSale.ContributorApprover(KyberContributorWhitelist,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.contributorCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.eligible(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.eligibleTestAndIncrement(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.saleEnded()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.saleStarted()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.KyberNetworkTokenSale(address,address,KyberContributorWhitelist,uint256,uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.setHaltSale(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.proxyBuy(bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.sendETHToMultiSig(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.finalizeSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.emergencyDrain(ERC20)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkTokenSale.debugBuy()
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract KyberContributorWhitelist
	To analyze：KyberContributorWhitelist.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.KyberContributorWhitelist()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.listAddress(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.listAddresses(address[],uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.setSlackUsersCap(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.getCap(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberContributorWhitelist.destroy()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract BasicToken
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20
Start Contract StandardToken
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract KyberNetworkCrystal
	To analyze：KyberNetworkCrystal.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.KyberNetworkCrystal(uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.burnFrom(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KyberNetworkCrystal.emergencyERC20Drain(ERC20,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test719.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.assert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Token
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ReserveToken
	To analyze：ReserveToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.ReserveToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.create(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.destroy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevels
	To analyze：AccountLevels.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevelsTest
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.setAccountLevel(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ExToke
	To analyze：ExToke.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.ExToke(address,address,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.changeAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.changeAccountLevelsAddr(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.changeFeeAccount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.changeFeeMake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.changeFeeTake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.changeFeeRebate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.withdraw(uint256)
		contract: ExToke | function: withdraw(uint256) | accessPermision: False | 锁: True | 钱提前更新：False
			path: ['entryPoint', 'tokens[0][msg.sender] < amount', 'None', 'tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)', '! msg.sender.call.value(amount)()']
[cfg_Reentrancy in] contract: ExToke . function: withdraw(uint256) | Reentrancy\test74.sol#234-239
	To analyze：ExToke.depositToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.balanceOf(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.order(address,uint256,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.tradeBalances(address,uint256,address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ExToke.cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test74.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Certifiable
	To analyze：Certifiable.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Certifiable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Certifiable.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Certifiable.updateCertifier(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract KYCToken
	To analyze：KYCToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCToken.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCToken.updateCertifier(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCToken.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCToken.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KYCToken.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract Certifier
Start Contract Crowdsale
	To analyze：Crowdsale.Crowdsale(uint256,address,ERC20)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale._postValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale._processPurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale._updatePurchasingState(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale._getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Crowdsale._forwardFunds()
		cfg分析安全，所以开始ICFG的分析
Start Contract TimedCrowdsale
	To analyze：TimedCrowdsale.Crowdsale(uint256,address,ERC20)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._postValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._processPurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._updatePurchasingState(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale.TimedCrowdsale(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale.hasClosed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：TimedCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AllowanceCrowdsale
	To analyze：AllowanceCrowdsale.Crowdsale(uint256,address,ERC20)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._postValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._processPurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._updatePurchasingState(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale.AllowanceCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AllowanceCrowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC20Basic
Start Contract ERC20
Start Contract ERC827
Start Contract BasicToken
	To analyze：BasicToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BasicToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC827Token
	To analyze：ERC827Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ERC827Token.approveAndCall(address,uint256,bytes)
		contract: ERC827Token | function: approveAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.approve(_spender,_value)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: approveAndCall(address,uint256,bytes) | Reentrancy\test745.sol#544-552
	To analyze：ERC827Token.transferAndCall(address,uint256,bytes)
		contract: ERC827Token | function: transferAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transfer(_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: transferAndCall(address,uint256,bytes) | Reentrancy\test745.sol#564-572
	To analyze：ERC827Token.transferFromAndCall(address,address,uint256,bytes)
		contract: ERC827Token | function: transferFromAndCall(address,address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transferFrom(_from,_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: transferFromAndCall(address,address,uint256,bytes) | Reentrancy\test745.sol#585-600
	To analyze：ERC827Token.increaseApprovalAndCall(address,uint256,bytes)
		contract: ERC827Token | function: increaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.increaseApproval(_spender,_addedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: increaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test745.sol#615-624
	To analyze：ERC827Token.decreaseApprovalAndCall(address,uint256,bytes)
		contract: ERC827Token | function: decreaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.decreaseApproval(_spender,_subtractedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: ERC827Token . function: decreaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test745.sol#639-648
Start Contract BurnableToken
	To analyze：BurnableToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BurnableToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BurnableToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BurnableToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BurnableToken._burn(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EDUToken
	To analyze：EDUToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.approveAndCall(address,uint256,bytes)
		contract: EDUToken | function: approveAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.approve(_spender,_value)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: EDUToken . function: approveAndCall(address,uint256,bytes) | Reentrancy\test745.sol#544-552
	To analyze：EDUToken.transferAndCall(address,uint256,bytes)
		contract: EDUToken | function: transferAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transfer(_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: EDUToken . function: transferAndCall(address,uint256,bytes) | Reentrancy\test745.sol#564-572
	To analyze：EDUToken.transferFromAndCall(address,address,uint256,bytes)
		contract: EDUToken | function: transferFromAndCall(address,address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_to != address(this))', 'super.transferFrom(_from,_to,_value)', 'require(bool)(_to.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: EDUToken . function: transferFromAndCall(address,address,uint256,bytes) | Reentrancy\test745.sol#585-600
	To analyze：EDUToken.increaseApprovalAndCall(address,uint256,bytes)
		contract: EDUToken | function: increaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.increaseApproval(_spender,_addedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: EDUToken . function: increaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test745.sol#615-624
	To analyze：EDUToken.decreaseApprovalAndCall(address,uint256,bytes)
		contract: EDUToken | function: decreaseApprovalAndCall(address,uint256,bytes) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(_spender != address(this))', 'super.decreaseApproval(_spender,_subtractedValue)', 'require(bool)(_spender.call.value(msg.value)(_data))']
[cfg_Reentrancy in] contract: EDUToken . function: decreaseApprovalAndCall(address,uint256,bytes) | Reentrancy\test745.sol#639-648
	To analyze：EDUToken.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.updateCertifier(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.addManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.removeManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.burn(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken._burn(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.increaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.decreaseApproval(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUToken.delayedTransferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CappedCrowdsale
	To analyze：CappedCrowdsale.Crowdsale(uint256,address,ERC20)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._postValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._processPurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._updatePurchasingState(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.CappedCrowdsale(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale.capReached()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CappedCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract EDUCrowdsale
	To analyze：EDUCrowdsale.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.updateCertifier(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.Crowdsale(uint256,address,ERC20)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.buyTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._postValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._processPurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._updatePurchasingState(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._forwardFunds()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.TimedCrowdsale(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.hasClosed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.CappedCrowdsale(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.capReached()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._preValidatePurchase(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.AllowanceCrowdsale(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.remainingTokens()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.constructor(address,EDUToken,address,uint256,uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._deliverTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.getCurrentRate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._getTokenAmount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale._getVolumeBonus(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.changeTokenWallet(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EDUCrowdsale.changeWallet(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test745.sol
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.assert(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Token
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract StandardToken
	To analyze：StandardToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：StandardToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ReserveToken
	To analyze：ReserveToken.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.ReserveToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.create(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ReserveToken.destroy(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevels
	To analyze：AccountLevels.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccountLevelsTest
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.setAccountLevel(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccountLevelsTest.accountLevel(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherDelta
	To analyze：EtherDelta.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.assert(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.EtherDelta(address,address,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeAccountLevelsAddr(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeAccount(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeMake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeTake(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.changeFeeRebate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.deposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.withdraw(uint256)
		contract: EtherDelta | function: withdraw(uint256) | accessPermision: False | 锁: True | 钱提前更新：False
			path: ['entryPoint', 'tokens[0][msg.sender] < amount', 'None', 'tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)', '! msg.sender.call.value(amount)()']
[cfg_Reentrancy in] contract: EtherDelta . function: withdraw(uint256) | Reentrancy\test772.sol#219-224
	To analyze：EtherDelta.depositToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.withdrawToken(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.balanceOf(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.order(address,uint256,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.tradeBalances(address,uint256,address,uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherDelta.cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test772.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mul(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(int256,int256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.mod(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract GeneScienceInterface
Start Contract ERC20
Start Contract SignatureVerifier
	To analyze：SignatureVerifier.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SignatureVerifier.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract AccessControl
	To analyze：AccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAccessControl
	To analyze：PonyAccessControl.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBase
	To analyze：PonyBase.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBase.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyOwnership
	To analyze：PonyOwnership.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyOwnership.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyBreeding
	To analyze：PonyBreeding.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyBreeding.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuctionBase
	To analyze：ClockAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pausable
	To analyze：Pausable.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pausable.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract ClockAuction
	To analyze：ClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract SiringClockAuction
	To analyze：SiringClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SiringClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract SaleClockAuction
	To analyze：SaleClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._addAuction(uint256,ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidEth(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._bidDkl(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._isOnAuction(ClockAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.getCurrentPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.constructor(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createEthAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.createDklAuction(uint256,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidEth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.bidDkl(uint256,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：SaleClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyAuction
	To analyze：PonyAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyAuction.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuctionBase
	To analyze：BiddingAuctionBase._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuctionBase._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingAuction
	To analyze：BiddingAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingWallet
	To analyze：BiddingWallet.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract BiddingClockAuction
	To analyze：BiddingClockAuction.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSystemAddress(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.depositDekla(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawAmountHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawEth(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDekla(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidEth(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.winBidDekla(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._escrow(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._addAuction(uint256,BiddingAuctionBase.Auction)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._cancelAuction(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._removeAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction._computeCut(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionHashing(uint256,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuction(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.cancelAuctionWhenPaused(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.constructor(address,address,address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createETHAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.setCut(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.createDklAuction(uint256,address,uint16,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEndHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionEthEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.auctionDeklaEnd(address,uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BiddingClockAuction.withdrawDklBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyMinting
	To analyze：PonyMinting.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyMinting.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyUpgrade
	To analyze：PonyUpgrade.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyUpgrade.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract PonyCore
	To analyze：PonyCore.splitSignature(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.recover(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedByCLevel(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.signedBySystem(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCEOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCEO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCFOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCFO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getCOOHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setCOO(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getNonces(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._createPony(uint256,uint256,uint256,uint256,address,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSecondsPerBlock(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approvedFor(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._approve(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.transferPreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSignedHashing(address,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approvePreSigned(bytes,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToMate(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isMatingPermitted(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerCooldown(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._triggerPregnant(PonyBase.Pony,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.approveSiring(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setAutoBirthFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isReadyToGiveBirth(PonyBase.Pony)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isReadyToMate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.isPregnant(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._isValidMatingPair(PonyBase.Pony,uint256,PonyBase.Pony,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWithViaAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.canMateWith(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore._mateWith(uint256,uint256,uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getIncubatorHashing(address,uint8,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.mateWithAuto(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.giveBirth(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setMatingSeason(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingAuctionAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSaleAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklSiringAuction(uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.delegateDklBidAuction(uint256,uint256,bytes,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSaleAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDklSiringAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createEthBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createDeklaBidAuction(uint256,uint256,uint16)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnEthSiringAuction(uint256,uint256,uint8,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.bidOnDklSiringAuction(uint256,uint256,uint8,bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionBalances()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawAuctionDklBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setBiddingRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSaleRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setSiringRate(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createPromoPony(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.createGen0(uint256,uint256,uint16,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePonyHashing(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.upgradePony(uint256,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.constructor(address,address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getTokenAddressHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setTokenAddress(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.setNewAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.getPony(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawBalanceHashing(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawEthBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PonyCore.withdrawDeklaBalance(address,bytes)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test784.sol
Start Contract Ownable
	To analyze：Ownable.Ownable()
		cfg分析安全，所以开始ICFG的分析
Start Contract AddressLottery
	To analyze：AddressLottery.Ownable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.AddressLottery()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.participate()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.luckyNumberOfAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.reseed(AddressLottery.SeedComponents)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.kill()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.forceReseed()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AddressLottery.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test793.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min64(uint64,uint64)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.max256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.min256(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract tokenRecipient
Start Contract NamiCrowdSale
	To analyze：NamiCrowdSale.NamiCrowdSale(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferForTeam(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeTransferable()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinary(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.changeBinaryAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.getPrice()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.buy(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.burnTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setPresalePhase(NamiCrowdSale.Phase)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.setCrowdsaleManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale._migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateToken(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.migrateForInvestor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiCrowdSale.transferToBuyer(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract BinaryOption
	To analyze：BinaryOption.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.BinaryOption(address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeEscrow(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeRate(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.changeTimeOneSession(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.withdrawEther(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.safeWithdraw(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getInvestors()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getChooses()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getAmount()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.resetSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.openSession()
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.invest(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeInvest(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.getEtherToBuy(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BinaryOption.closeSession(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract PresaleToken
Start Contract ERC223ReceivingContract
Start Contract NamiExchange
	To analyze：NamiExchange.NamiExchange(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallback(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.placeBuyOrder(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallbackBuyer(address,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeBidOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.tokenFallbackExchange(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.closeAskOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiExchange.buyNac(address)
		contract: NamiExchange | function: buyNac(address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)', 'asset = ERC23(NamiAddr)', 'maxEth = (ask[_seller].volume).div(ask[_seller].price)', 'msg.value > maxEth', '_seller.send(maxEth) && msg.sender.send(msg.value.sub(maxEth)) && asset.transfer(msg.sender,ask[_seller].volume)']
		contract: NamiExchange | function: buyNac(address) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'require(bool)(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0)', 'asset = ERC23(NamiAddr)', 'maxEth = (ask[_seller].volume).div(ask[_seller].price)', 'msg.value > maxEth', '_seller.send(msg.value) && asset.transfer(msg.sender,(msg.value).mul(ask[_seller].price))']
[cfg_Reentrancy in] contract: NamiExchange . function: buyNac(address) | Reentrancy\test799.sol#1007-1033
Start Contract ERC23
Start Contract NamiMultiSigWallet
	To analyze：NamiMultiSigWallet.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.NamiMultiSigWallet(address[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.replaceOwner(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.changeRequirement(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.submitTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.confirmTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.revokeConfirmation(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.executeTransaction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.isConfirmed(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.addTransaction(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmationCount(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionCount(bool,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getOwners()
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getConfirmations(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：NamiMultiSigWallet.getTransactionIds(uint256,uint256,bool,bool)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test799.sol
Start Contract ArrayLib
	To analyze：ArrayLib.insertInPlace(uint8[],uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract DeckLib
	To analyze：DeckLib.init(DeckLib.Deck,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.getCard(DeckLib.Deck,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.cardDescription(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.cardEmojified(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.cardFacevalue(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.blackjackValue(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DeckLib.getRandomNumber(uint256,address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AbstractBlockjackLogs
Start Contract GameLib
	To analyze：GameLib.init(GameLib.Game,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.tick(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.needsTick(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.checkGameResult(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.checkGameContinues(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.forceStand(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.canDoubleDown(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.playerDecision(GameLib.Game,GameLib.GameState)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.dealInitialCards(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.dealHitCard(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.dealHouseCards(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.endGame(GameLib.Game,GameLib.GameResult)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.closeGame(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.payoutForResult(GameLib.GameResult,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.countHand(uint8[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.bestSum(uint8[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.appendArray(uint8[],uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GameLib.compareHands(uint8,uint8)
		cfg分析安全，所以开始ICFG的分析
Start Contract Blockjack
	To analyze：Blockjack.Blockjack(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.startGame()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.hit(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.doubleDown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.stand(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.gameTick(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.recordEndedGame(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.tickRequiredLog(GameLib.Game)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.gameState(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.setupTrustedAccounts()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.changeDev(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.changeDX(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.changeAdminContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.setSettings(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.registerOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.removeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.stopBlockjack()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.startBlockjack()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.addBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.remainingBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.removeBankroll()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.migrateBlockjack()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Blockjack.shareProfits()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test853.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Ownable
	To analyze：Ownable.constructor()
		cfg分析安全，所以开始ICFG的分析
Start Contract EtherheroStabilizationFund
	To analyze：EtherheroStabilizationFund.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.ReturnEthToEtherhero()
		cfg分析安全，所以开始ICFG的分析
	To analyze：EtherheroStabilizationFund.fallback()
		cfg分析安全，所以开始ICFG的分析
Start Contract Etherhero
	To analyze：Etherhero.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.insertBeneficiaries(address,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.getBeneficiaries(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.calculationOfPayment()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.receivePercent()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.makeDeposit()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Etherhero.fallback()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test86.sol
Start Contract REPOPAccessControl
	To analyze：REPOPAccessControl.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPAccessControl.unpause()
		cfg分析安全，所以开始ICFG的分析
Start Contract PullPayment
	To analyze：PullPayment.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PullPayment.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
Start Contract ERC721
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MetadataContract
	To analyze：MetadataContract.getMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._memcpy(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract._toString(bytes32[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.getMetadataUrl(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MetadataContract.uintToBytes(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPERC721
	To analyze：REPOPERC721.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPERC721.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CarefulTransfer
	To analyze：CarefulTransfer.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract MoneyManager
	To analyze：MoneyManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MoneyManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
Start Contract RoundMoneyNicely
	To analyze：RoundMoneyNicely.roundMoneyDownNicely(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RoundMoneyNicely.roundMoneyUpToWholeFinney(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract AuctionManager
	To analyze：AuctionManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.AuctionManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllActiveAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAllAuctions()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.createAuction(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.bid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.endAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.requiredBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuction(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.getAuctionStartBid()
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager.setAuctionStartBid(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：AuctionManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MarketManager
	To analyze：MarketManager.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.MarketManager()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllActiveSales()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.getAllSalesByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.purchasePop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.sellPop(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.cancelSellPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager.changeSellPOPPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfToken(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MarketManager._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract CloningInterface
Start Contract GenesMarket
	To analyze：GenesMarket.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.GenesMarket()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.setERCContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getERCContractAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.startSellingGenes(uint256,uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.stopSellingGenes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.sellerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.useBottle(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.purchaseGenes(uint256,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSale()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getGenesForSaleBySeller(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getAmountOfGene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.getMyGenes()
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket.changeSellGenesPrice(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：GenesMarket._takeOwnershipOfTokenFrom(uint256,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract REPOPCore
	To analyze：REPOPCore.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCFO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.pause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.unpause()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.carefulSendWithFixedGas(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.asyncSend(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdrawPayments()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._repopTransaction(address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.withdraw(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getBalance()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokenMetadata(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMetadataContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.supportsInterface(bytes4)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getPop(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewPop(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._triggerCooldown(REPOPERC721.Pop)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.stringToBytes32(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopNameOriginal(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setDNA(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.REPOPCore()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.createNewAuction(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setAuctionManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getAuctionManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setMarketManagerAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getMarketManagerAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGeneScienceAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGeneScienceAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setGenesMarketAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getGenesMarketAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellPop(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.sellGenes(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnerInAnyPlatformById(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.setPopName(uint256,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.removeCooldown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore._ownerOfPopInAnyPlatform(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.getOwnershipForCloning(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.changeRefresherFee(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithTwoPops(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：REPOPCore.cloneWithPopAndBottle(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test864.sol
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract strings
	To analyze：strings.memcpy(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.toSlice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.len(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.toSliceB32(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.copy(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.toString(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.len(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.empty(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.compare(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.equals(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.nextRune(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.nextRune(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.ord(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.keccak(strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.startsWith(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.beyond(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.endsWith(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.until(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.findPtr(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rfindPtr(uint256,uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.find(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rfind(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.split(strings.slice,strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.split(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rsplit(strings.slice,strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.rsplit(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.count(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.contains(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.concat(strings.slice,strings.slice)
		cfg分析安全，所以开始ICFG的分析
	To analyze：strings.join(strings.slice,strings.slice[])
		cfg分析安全，所以开始ICFG的分析
Start Contract DSSafeAddSub
	To analyze：DSSafeAddSub.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：DSSafeAddSub.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract LuckyETH
	To analyze：LuckyETH.safeToAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.safeToSubtract(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_randomDS_proofVerify__returnCode(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.LuckyETH()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.toAsciiString(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.char(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.setCaissa()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.encrypt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.playerRollDiceSingle(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.playerRollDice(uint256,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.playerWithdrawPendingTransactions()
		contract: LuckyETH | function: playerWithdrawPendingTransactions() | accessPermision: False | 锁: False | 钱提前更新：True
			path: ['entryPoint', 'withdrawAmount = playerPendingWithdrawals[msg.sender]', 'playerPendingWithdrawals[msg.sender] = 0', 'msg.sender.call.value(withdrawAmount)()']
[cfg_Reentrancy in] contract: LuckyETH . function: playerWithdrawPendingTransactions() | Reentrancy\test892.sol#2007-2019
	To analyze：LuckyETH.playerGetPendingTxByAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerSetCallbackGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerSetOraclizeSafeGas(uint32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerSetMinBet(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerTransferEther(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerRefundPlayer(bytes32,address,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerPauseGame(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerPausePayouts(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerSetTreasury(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerChangeOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：LuckyETH.ownerkill()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test892.sol
Start Contract RNG
	To analyze：RNG.requestRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：RNG.getUncorrelatedRN(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Arbitrator
	To analyze：Arbitrator.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrator.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract IArbitrable
Start Contract Arbitrable
	To analyze：Arbitrable.constructor(Arbitrator,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Arbitrable.rule(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract Controlled
	To analyze：Controlled.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Controlled.changeController(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract ApproveAndCallFallBack
Start Contract MiniMeToken
	To analyze：MiniMeToken.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MiniMeToken.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract MiniMeTokenFactory
	To analyze：MiniMeTokenFactory.createCloneToken(address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
Start Contract Pinakion
	To analyze：Pinakion.Controlled()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.changeController(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.MiniMeToken(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.doTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.approveAndCall(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.balanceOfAt(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.totalSupplyAt(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.createCloneToken(string,uint8,string,uint256,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.generateTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.destroyTokens(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.enableTransfers(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.getValueAt(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.updateValueAtNow(MiniMeToken.Checkpoint[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.isContract(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.min(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.claimTokens(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.constructor(address,address,uint256,string,uint8,string,bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Pinakion.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract TokenController
Start Contract SortitionSumTreeFactory
	To analyze：SortitionSumTreeFactory.createTree(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.set(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.queryLeafs(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.draw(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.stakeOf(SortitionSumTreeFactory.SortitionSumTrees,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SortitionSumTreeFactory.updateParents(SortitionSumTreeFactory.SortitionSumTrees,bytes32,uint256,bool,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract BlockHashRNG
	To analyze：BlockHashRNG.requestRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.getUncorrelatedRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.contribute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.getRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.saveRN(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：BlockHashRNG.getFallbackRN(uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract KlerosLiquid
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.constructor(address,Pinakion,RNG,uint256,uint256,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeGovernorProposal(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeRNGenerator(RNG)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createSubcourt(uint96,bool,uint256,uint256,uint256,uint256,uint256[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtMinStake(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtAlpha(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorFee(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtJurorsForJump(uint96,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.changeSubcourtTimesPerPeriod(uint96,uint256[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPhase()
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.passPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.setStake(uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeDelayedSetStakes(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.drawJurors(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.commit(uint256,uint256[],bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.vote(uint256,uint256[],uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.computeTokenAndETHRewards(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.execute(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.executeRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.createDispute(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appeal(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.proxyPayment(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onTransfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.onApprove(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.arbitrationCost(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealCost(uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.appealPeriod(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.disputeStatus(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.currentRuling(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid._setStake(address,uint96,uint128)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.extraDataToSubcourtIDAndMinJurors(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.accountAndSubcourtIDToStakePathID(address,uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakePathIDToAccountAndSubcourtID(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getSubcourt(uint96)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVote(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getVoteCounter(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getDispute(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.getJuror(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：KlerosLiquid.stakeOf(address,uint96)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test901.sol
Start Contract Ownable
	To analyze：Ownable.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Ownable._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
Start Contract TVCrowdsale
Start Contract TVToken
Start Contract MTVote
	To analyze：MTVote.constructor()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.renounceOwnership()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote._transferOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.constructor(address,address,address,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.changeAndVote(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.onTokenReceived(address,uint256,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.setPause(bool)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.clear()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.changeTVTokenAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.changeTVCrowdsaleAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.setManager(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.convertBytesToBytes32(bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.bytesToUint(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MTVote.toBytes(uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test911.sol
Start Contract ERC721
Start Contract PornstarsInterface
Start Contract PornSceneToken
	To analyze：PornSceneToken.PornSceneToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setPornstarsContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.createPromoScene(address,string,uint256[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.createContractScene(string,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.getScene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._paySceneStarOwners(PornSceneToken.Scene,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._payAwardOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._isGoodAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.starsOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._createScene(string,uint256[],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：PornSceneToken._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract CryptoPornstarAward
	To analyze：CryptoPornstarAward.PornSceneToken()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setPornstarsContractAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.createPromoScene(address,string,uint256[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.createContractScene(string,uint256[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getScene(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.implementsERC721()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.name()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.ownerOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.purchase(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._paySceneStarOwners(PornSceneToken.Scene,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._payAwardOwner(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._isGoodAddress(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.priceOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.starsOf(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCEO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCOO(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.symbol()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.takeOwnership(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.tokensOfOwner(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._addressNotNull(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._approved(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._createScene(string,uint256[],address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._owns(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._payout(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._transfer(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._triggerCooldown()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward._isTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.rand(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.setCooldown(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getAwardTime()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getCooldown()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.newAward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：CryptoPornstarAward.getCurrentAward()
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test915.sol
Start Contract Token
	To analyze：Token.totalSupply()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.balanceOf(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transfer(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.transferFrom(address,address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.approve(address,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Token.allowance(address,address)
		cfg分析安全，所以开始ICFG的分析
Start Contract SafeMath
	To analyze：SafeMath.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract ShortOrder
	To analyze：ShortOrder.safeMul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.safeDiv(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.safeSub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.safeAdd(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.ShortOrder()
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.changeAdmin(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.tokenFulfillmentDeposit(address[2],uint256,uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.depositCoupon(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.placeLong(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.buyLong(address[2],uint256[3],uint8,bytes32[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.exerciseLong(address[2],uint256[8],uint8,bytes32[2])
		contract: ShortOrder | function: exerciseLong(address[2],uint256[8],uint8,bytes32[2]) | accessPermision: False | 锁: False | 钱提前更新：False
			path: ['entryPoint', 'orderHash = keccak256()(tokenUser[0],tokenUser[1],minMaxDMWCPNonce[0],minMaxDMWCPNonce[1],minMaxDMWCPNonce[2],minMaxDMWCPNonce[3],minMaxDMWCPNonce[4],minMaxDMWCPNonce[5],minMaxDMWCPNonce[6],minMaxDMWCPNonce[7])', 'require(bool)(ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(\x19Ethereum Signed Message:\n32,orderHash),v,rs[0],rs[1]) == tokenUser[1] && block.number > minMaxDMWCPNonce[3] && block.number <= minMaxDMWCPNonce[4] && orderRecord[tokenUser[1]][orderHash].balance >= minMaxDMWCPNonce[0])', 'couponProportion = safeDiv(orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender],orderRecord[tokenUser[1]][orderHash].balance)', 'None', 'orderRecord[msg.sender][orderHash].tokenDeposit', 'couponAmount = safeMul(orderRecord[tokenUser[1]][orderHash].coupon,couponProportion)', 'amount = safeMul(orderRecord[tokenUser[1]][orderHash].longBalance[msg.sender],minMaxDMWCPNonce[6])', 'msg.sender.transfer(couponAmount)', 'Token(tokenUser[0]).transfer(msg.sender,amount)']
[cfg_Reentrancy in] contract: ShortOrder . function: exerciseLong(address[2],uint256[8],uint8,bytes32[2]) | Reentrancy\test958.sol#189-229
	To analyze：ShortOrder.claimDonations(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.nonActivationShortWithdrawal(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.nonActivationWithdrawal(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnBalance(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnTokenBalance(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnUserBalance(address,address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnCoupon(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnTokenDepositState(address[2],uint256[8],uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnHash(address[2],uint256[8])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnAddress(bytes32,uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnHashLong(address,uint256[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：ShortOrder.returnLongAddress(bytes32,uint8,bytes32[2])
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test958.sol
Start Contract SafeMath
	To analyze：SafeMath.mul(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.div(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.sub(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：SafeMath.add(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
Start Contract OraclizeI
Start Contract OraclizeAddrResolverI
Start Contract usingOraclize
	To analyze：usingOraclize.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：usingOraclize.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
Start Contract BettingControllerInterface
Start Contract Betting
	To analyze：Betting.oraclize_setNetwork(uint8)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_useCoupon(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getPrice(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getPrice(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string,string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,string[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[1])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[1],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[2])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[2],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[3])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[3],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[4])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[4],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[5])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(uint256,string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_query(string,bytes[5],uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_cbAddress()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setProof(bytes1)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setCustomGasPrice(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setConfig(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_getSessionPubKeyHash()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.getCodeSize(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseAddr(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strCompare(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.indexOf(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.strConcat(string,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseInt(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.parseInt(string,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.uint2str(uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.stra2cbor(string[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.ba2cbor(bytes[])
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_setNetworkName(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_getNetworkName()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_newRandomDSQuery(uint256,uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_setCommitment(bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.verifySig(bytes32,bytes,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_proofVerify__sessionKeyValidity(bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.matchBytes32Prefix(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.oraclize_randomDS_proofVerify__main(bytes,bytes32,bytes,string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.copyBytes(bytes,uint256,uint256,bytes,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.safer_ecrecover(bytes32,uint8,bytes32,bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.ecrecovery(bytes32,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.Betting()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.changeOwnership(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.__callback(bytes32,string,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.placeBet(bytes32)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.setupRace(uint256,uint256)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.reward()
		contract: Betting | function: reward() | accessPermision: False | 锁: False | 钱提前更新：True
			path: ['entryPoint', 'horses.BTC_delta = int64(coinIndex[horses.BTC].post - coinIndex[horses.BTC].pre) * 100000 / int64(coinIndex[horses.BTC].pre)', 'horses.ETH_delta = int64(coinIndex[horses.ETH].post - coinIndex[horses.ETH].pre) * 100000 / int64(coinIndex[horses.ETH].pre)', 'horses.LTC_delta = int64(coinIndex[horses.LTC].post - coinIndex[horses.LTC].pre) * 100000 / int64(coinIndex[horses.LTC].pre)', 'total_reward = (coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total)', 'total_bettors <= 1', 'house_fee = total_reward.mul(5).div(100)', 'require(bool)(house_fee < address(this).balance)', 'total_reward = total_reward.sub(house_fee)', 'bettingControllerInstance.depositHouseTakeout.value(house_fee)()']
[cfg_Reentrancy in] contract: Betting . function: reward() | Reentrancy\test977.sol#1264-1325
	To analyze：Betting.calculateReward(address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.checkReward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.claim_reward()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.forceVoidRace()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.stringToUintNormalize(string)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.getCoinIndex(bytes32,address)
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.reward_total()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.refund()
		cfg分析安全，所以开始ICFG的分析
	To analyze：Betting.recovery()
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test977.sol
Start Contract MultiplicatorX4
	To analyze：MultiplicatorX4.fallback()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MultiplicatorX4.withdraw()
		cfg分析安全，所以开始ICFG的分析
	To analyze：MultiplicatorX4.Command(address,bytes)
		cfg分析安全，所以开始ICFG的分析
	To analyze：MultiplicatorX4.multiplicate(address)
		cfg分析安全，所以开始ICFG的分析
./Reentrancy\test989.sol
